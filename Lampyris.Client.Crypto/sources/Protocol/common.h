// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 5.29.3

#ifndef common_2eproto_2epb_2eh
#define common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "account.h"
#include "app.h"
#include "quote.h"
#include "strategy.h"
#include "trading.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2eproto;
namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class Request final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Request* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Request));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Request(
      ::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from) : Request(nullptr, from) {}
  inline Request(Request&& from) noexcept
      : Request(nullptr, std::move(from)) {}
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kReqAccountSummaryUpdate = 1,
    kReqAccountAssetTransfer = 2,
    kReqQueryAssetTransferHistory = 3,
    kReqLogin = 4,
    kReqLogout = 5,
    kReqHeartBeat = 6,
    kReqUploadAppBehaviour = 7,
    kReqSubscribeTickerData = 8,
    kReqSubscribeTradeData = 9,
    kReqSubscribeCandlestickUpdate = 10,
    kReqCandlestickQuery = 11,
    kReqTradeRule = 12,
    kReqSelfSelectedSymbol = 13,
    kReqModifyStreategySetting = 14,
    kReqQueryStrategyExectionInfo = 15,
    kReqPlaceOrder = 16,
    kReqModifyOrder = 17,
    kReqCancelOrder = 18,
    kReqOneKeyClosePosition = 19,
    kReqQueryActiveOrders = 20,
    kReqQueryHistoricalOrders = 21,
    kReqQueryPositions = 22,
    kReqSetLeverage = 23,
    kReqQueryLeverage = 24,
    kReqQueryLeverageBracket = 25,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
        &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Request& a, Request& b) { a.Swap(&b); }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Request& from) { Request::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Request* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Request"; }

 protected:
  explicit Request(::google::protobuf::Arena* arena);
  Request(::google::protobuf::Arena* arena, const Request& from);
  Request(::google::protobuf::Arena* arena, Request&& from) noexcept
      : Request(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReqAccountSummaryUpdateFieldNumber = 1,
    kReqAccountAssetTransferFieldNumber = 2,
    kReqQueryAssetTransferHistoryFieldNumber = 3,
    kReqLoginFieldNumber = 4,
    kReqLogoutFieldNumber = 5,
    kReqHeartBeatFieldNumber = 6,
    kReqUploadAppBehaviourFieldNumber = 7,
    kReqSubscribeTickerDataFieldNumber = 8,
    kReqSubscribeTradeDataFieldNumber = 9,
    kReqSubscribeCandlestickUpdateFieldNumber = 10,
    kReqCandlestickQueryFieldNumber = 11,
    kReqTradeRuleFieldNumber = 12,
    kReqSelfSelectedSymbolFieldNumber = 13,
    kReqModifyStreategySettingFieldNumber = 14,
    kReqQueryStrategyExectionInfoFieldNumber = 15,
    kReqPlaceOrderFieldNumber = 16,
    kReqModifyOrderFieldNumber = 17,
    kReqCancelOrderFieldNumber = 18,
    kReqOneKeyClosePositionFieldNumber = 19,
    kReqQueryActiveOrdersFieldNumber = 20,
    kReqQueryHistoricalOrdersFieldNumber = 21,
    kReqQueryPositionsFieldNumber = 22,
    kReqSetLeverageFieldNumber = 23,
    kReqQueryLeverageFieldNumber = 24,
    kReqQueryLeverageBracketFieldNumber = 25,
  };
  // .lampyris.crypto.protocol.account.ReqAccountSummaryUpdate reqAccountSummaryUpdate = 1;
  bool has_reqaccountsummaryupdate() const;
  private:
  bool _internal_has_reqaccountsummaryupdate() const;

  public:
  void clear_reqaccountsummaryupdate() ;
  const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& reqaccountsummaryupdate() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* release_reqaccountsummaryupdate();
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* mutable_reqaccountsummaryupdate();
  void set_allocated_reqaccountsummaryupdate(::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* value);
  void unsafe_arena_set_allocated_reqaccountsummaryupdate(::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* value);
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* unsafe_arena_release_reqaccountsummaryupdate();

  private:
  const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& _internal_reqaccountsummaryupdate() const;
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* _internal_mutable_reqaccountsummaryupdate();

  public:
  // .lampyris.crypto.protocol.account.ReqAccountAssetTransfer reqAccountAssetTransfer = 2;
  bool has_reqaccountassettransfer() const;
  private:
  bool _internal_has_reqaccountassettransfer() const;

  public:
  void clear_reqaccountassettransfer() ;
  const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& reqaccountassettransfer() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* release_reqaccountassettransfer();
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* mutable_reqaccountassettransfer();
  void set_allocated_reqaccountassettransfer(::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* value);
  void unsafe_arena_set_allocated_reqaccountassettransfer(::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* value);
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* unsafe_arena_release_reqaccountassettransfer();

  private:
  const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& _internal_reqaccountassettransfer() const;
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* _internal_mutable_reqaccountassettransfer();

  public:
  // .lampyris.crypto.protocol.account.ReqQueryAssetTransferHistory reqQueryAssetTransferHistory = 3;
  bool has_reqqueryassettransferhistory() const;
  private:
  bool _internal_has_reqqueryassettransferhistory() const;

  public:
  void clear_reqqueryassettransferhistory() ;
  const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& reqqueryassettransferhistory() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* release_reqqueryassettransferhistory();
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* mutable_reqqueryassettransferhistory();
  void set_allocated_reqqueryassettransferhistory(::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* value);
  void unsafe_arena_set_allocated_reqqueryassettransferhistory(::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* value);
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* unsafe_arena_release_reqqueryassettransferhistory();

  private:
  const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& _internal_reqqueryassettransferhistory() const;
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* _internal_mutable_reqqueryassettransferhistory();

  public:
  // .lampyris.crypto.protocol.app.ReqLogin reqLogin = 4;
  bool has_reqlogin() const;
  private:
  bool _internal_has_reqlogin() const;

  public:
  void clear_reqlogin() ;
  const ::lampyris::crypto::protocol::app::ReqLogin& reqlogin() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqLogin* release_reqlogin();
  ::lampyris::crypto::protocol::app::ReqLogin* mutable_reqlogin();
  void set_allocated_reqlogin(::lampyris::crypto::protocol::app::ReqLogin* value);
  void unsafe_arena_set_allocated_reqlogin(::lampyris::crypto::protocol::app::ReqLogin* value);
  ::lampyris::crypto::protocol::app::ReqLogin* unsafe_arena_release_reqlogin();

  private:
  const ::lampyris::crypto::protocol::app::ReqLogin& _internal_reqlogin() const;
  ::lampyris::crypto::protocol::app::ReqLogin* _internal_mutable_reqlogin();

  public:
  // .lampyris.crypto.protocol.app.ReqLogout reqLogout = 5;
  bool has_reqlogout() const;
  private:
  bool _internal_has_reqlogout() const;

  public:
  void clear_reqlogout() ;
  const ::lampyris::crypto::protocol::app::ReqLogout& reqlogout() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqLogout* release_reqlogout();
  ::lampyris::crypto::protocol::app::ReqLogout* mutable_reqlogout();
  void set_allocated_reqlogout(::lampyris::crypto::protocol::app::ReqLogout* value);
  void unsafe_arena_set_allocated_reqlogout(::lampyris::crypto::protocol::app::ReqLogout* value);
  ::lampyris::crypto::protocol::app::ReqLogout* unsafe_arena_release_reqlogout();

  private:
  const ::lampyris::crypto::protocol::app::ReqLogout& _internal_reqlogout() const;
  ::lampyris::crypto::protocol::app::ReqLogout* _internal_mutable_reqlogout();

  public:
  // .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 6;
  bool has_reqheartbeat() const;
  private:
  bool _internal_has_reqheartbeat() const;

  public:
  void clear_reqheartbeat() ;
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& reqheartbeat() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqHeartBeat* release_reqheartbeat();
  ::lampyris::crypto::protocol::app::ReqHeartBeat* mutable_reqheartbeat();
  void set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value);
  void unsafe_arena_set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value);
  ::lampyris::crypto::protocol::app::ReqHeartBeat* unsafe_arena_release_reqheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& _internal_reqheartbeat() const;
  ::lampyris::crypto::protocol::app::ReqHeartBeat* _internal_mutable_reqheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ReqUploadAppBehaviour reqUploadAppBehaviour = 7;
  bool has_requploadappbehaviour() const;
  private:
  bool _internal_has_requploadappbehaviour() const;

  public:
  void clear_requploadappbehaviour() ;
  const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& requploadappbehaviour() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* release_requploadappbehaviour();
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* mutable_requploadappbehaviour();
  void set_allocated_requploadappbehaviour(::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* value);
  void unsafe_arena_set_allocated_requploadappbehaviour(::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* value);
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* unsafe_arena_release_requploadappbehaviour();

  private:
  const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& _internal_requploadappbehaviour() const;
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* _internal_mutable_requploadappbehaviour();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 8;
  bool has_reqsubscribetickerdata() const;
  private:
  bool _internal_has_reqsubscribetickerdata() const;

  public:
  void clear_reqsubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& reqsubscribetickerdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* release_reqsubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* mutable_reqsubscribetickerdata();
  void set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value);
  void unsafe_arena_set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* unsafe_arena_release_reqsubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& _internal_reqsubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* _internal_mutable_reqsubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 9;
  bool has_reqsubscribetradedata() const;
  private:
  bool _internal_has_reqsubscribetradedata() const;

  public:
  void clear_reqsubscribetradedata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& reqsubscribetradedata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* release_reqsubscribetradedata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* mutable_reqsubscribetradedata();
  void set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value);
  void unsafe_arena_set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* unsafe_arena_release_reqsubscribetradedata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& _internal_reqsubscribetradedata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* _internal_mutable_reqsubscribetradedata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 10;
  bool has_reqsubscribecandlestickupdate() const;
  private:
  bool _internal_has_reqsubscribecandlestickupdate() const;

  public:
  void clear_reqsubscribecandlestickupdate() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& reqsubscribecandlestickupdate() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* release_reqsubscribecandlestickupdate();
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* mutable_reqsubscribecandlestickupdate();
  void set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value);
  void unsafe_arena_set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* unsafe_arena_release_reqsubscribecandlestickupdate();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& _internal_reqsubscribecandlestickupdate() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* _internal_mutable_reqsubscribecandlestickupdate();

  public:
  // .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 11;
  bool has_reqcandlestickquery() const;
  private:
  bool _internal_has_reqcandlestickquery() const;

  public:
  void clear_reqcandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& reqcandlestickquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* release_reqcandlestickquery();
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* mutable_reqcandlestickquery();
  void set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value);
  void unsafe_arena_set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value);
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* unsafe_arena_release_reqcandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& _internal_reqcandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* _internal_mutable_reqcandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 12;
  bool has_reqtraderule() const;
  private:
  bool _internal_has_reqtraderule() const;

  public:
  void clear_reqtraderule() ;
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& reqtraderule() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqTradeRule* release_reqtraderule();
  ::lampyris::crypto::protocol::quote::ReqTradeRule* mutable_reqtraderule();
  void set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value);
  void unsafe_arena_set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value);
  ::lampyris::crypto::protocol::quote::ReqTradeRule* unsafe_arena_release_reqtraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& _internal_reqtraderule() const;
  ::lampyris::crypto::protocol::quote::ReqTradeRule* _internal_mutable_reqtraderule();

  public:
  // .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 13;
  bool has_reqselfselectedsymbol() const;
  private:
  bool _internal_has_reqselfselectedsymbol() const;

  public:
  void clear_reqselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& reqselfselectedsymbol() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* release_reqselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* mutable_reqselfselectedsymbol();
  void set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value);
  void unsafe_arena_set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value);
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* unsafe_arena_release_reqselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& _internal_reqselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* _internal_mutable_reqselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.strategy.ReqModifyStreategySetting reqModifyStreategySetting = 14;
  bool has_reqmodifystreategysetting() const;
  private:
  bool _internal_has_reqmodifystreategysetting() const;

  public:
  void clear_reqmodifystreategysetting() ;
  const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& reqmodifystreategysetting() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* release_reqmodifystreategysetting();
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* mutable_reqmodifystreategysetting();
  void set_allocated_reqmodifystreategysetting(::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* value);
  void unsafe_arena_set_allocated_reqmodifystreategysetting(::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* value);
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* unsafe_arena_release_reqmodifystreategysetting();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& _internal_reqmodifystreategysetting() const;
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* _internal_mutable_reqmodifystreategysetting();

  public:
  // .lampyris.crypto.protocol.strategy.ReqQueryStrategyExectionInfo reqQueryStrategyExectionInfo = 15;
  bool has_reqquerystrategyexectioninfo() const;
  private:
  bool _internal_has_reqquerystrategyexectioninfo() const;

  public:
  void clear_reqquerystrategyexectioninfo() ;
  const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& reqquerystrategyexectioninfo() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* release_reqquerystrategyexectioninfo();
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* mutable_reqquerystrategyexectioninfo();
  void set_allocated_reqquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* value);
  void unsafe_arena_set_allocated_reqquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* value);
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* unsafe_arena_release_reqquerystrategyexectioninfo();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& _internal_reqquerystrategyexectioninfo() const;
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* _internal_mutable_reqquerystrategyexectioninfo();

  public:
  // .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 16;
  bool has_reqplaceorder() const;
  private:
  bool _internal_has_reqplaceorder() const;

  public:
  void clear_reqplaceorder() ;
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& reqplaceorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqPlaceOrder* release_reqplaceorder();
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* mutable_reqplaceorder();
  void set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value);
  void unsafe_arena_set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value);
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* unsafe_arena_release_reqplaceorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& _internal_reqplaceorder() const;
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* _internal_mutable_reqplaceorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 17;
  bool has_reqmodifyorder() const;
  private:
  bool _internal_has_reqmodifyorder() const;

  public:
  void clear_reqmodifyorder() ;
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& reqmodifyorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqModifyOrder* release_reqmodifyorder();
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* mutable_reqmodifyorder();
  void set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value);
  void unsafe_arena_set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value);
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* unsafe_arena_release_reqmodifyorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& _internal_reqmodifyorder() const;
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* _internal_mutable_reqmodifyorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 18;
  bool has_reqcancelorder() const;
  private:
  bool _internal_has_reqcancelorder() const;

  public:
  void clear_reqcancelorder() ;
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& reqcancelorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqCancelOrder* release_reqcancelorder();
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* mutable_reqcancelorder();
  void set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value);
  void unsafe_arena_set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value);
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* unsafe_arena_release_reqcancelorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& _internal_reqcancelorder() const;
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* _internal_mutable_reqcancelorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 19;
  bool has_reqonekeycloseposition() const;
  private:
  bool _internal_has_reqonekeycloseposition() const;

  public:
  void clear_reqonekeycloseposition() ;
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& reqonekeycloseposition() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* release_reqonekeycloseposition();
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* mutable_reqonekeycloseposition();
  void set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value);
  void unsafe_arena_set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value);
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* unsafe_arena_release_reqonekeycloseposition();

  private:
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& _internal_reqonekeycloseposition() const;
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* _internal_mutable_reqonekeycloseposition();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 20;
  bool has_reqqueryactiveorders() const;
  private:
  bool _internal_has_reqqueryactiveorders() const;

  public:
  void clear_reqqueryactiveorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& reqqueryactiveorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* release_reqqueryactiveorders();
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* mutable_reqqueryactiveorders();
  void set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value);
  void unsafe_arena_set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value);
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* unsafe_arena_release_reqqueryactiveorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& _internal_reqqueryactiveorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* _internal_mutable_reqqueryactiveorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 21;
  bool has_reqqueryhistoricalorders() const;
  private:
  bool _internal_has_reqqueryhistoricalorders() const;

  public:
  void clear_reqqueryhistoricalorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& reqqueryhistoricalorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* release_reqqueryhistoricalorders();
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* mutable_reqqueryhistoricalorders();
  void set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value);
  void unsafe_arena_set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value);
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* unsafe_arena_release_reqqueryhistoricalorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& _internal_reqqueryhistoricalorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* _internal_mutable_reqqueryhistoricalorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 22;
  bool has_reqquerypositions() const;
  private:
  bool _internal_has_reqquerypositions() const;

  public:
  void clear_reqquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& reqquerypositions() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryPositions* release_reqquerypositions();
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* mutable_reqquerypositions();
  void set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value);
  void unsafe_arena_set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value);
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* unsafe_arena_release_reqquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& _internal_reqquerypositions() const;
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* _internal_mutable_reqquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 23;
  bool has_reqsetleverage() const;
  private:
  bool _internal_has_reqsetleverage() const;

  public:
  void clear_reqsetleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& reqsetleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqSetLeverage* release_reqsetleverage();
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* mutable_reqsetleverage();
  void set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value);
  void unsafe_arena_set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value);
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* unsafe_arena_release_reqsetleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& _internal_reqsetleverage() const;
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* _internal_mutable_reqsetleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 24;
  bool has_reqqueryleverage() const;
  private:
  bool _internal_has_reqqueryleverage() const;

  public:
  void clear_reqqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& reqqueryleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryLeverage* release_reqqueryleverage();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* mutable_reqqueryleverage();
  void set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value);
  void unsafe_arena_set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* unsafe_arena_release_reqqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& _internal_reqqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* _internal_mutable_reqqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 25;
  bool has_reqqueryleveragebracket() const;
  private:
  bool _internal_has_reqqueryleveragebracket() const;

  public:
  void clear_reqqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& reqqueryleveragebracket() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* release_reqqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* mutable_reqqueryleveragebracket();
  void set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value);
  void unsafe_arena_set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* unsafe_arena_release_reqqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& _internal_reqqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* _internal_mutable_reqqueryleveragebracket();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Request)
 private:
  class _Internal;
  void set_has_reqaccountsummaryupdate();
  void set_has_reqaccountassettransfer();
  void set_has_reqqueryassettransferhistory();
  void set_has_reqlogin();
  void set_has_reqlogout();
  void set_has_reqheartbeat();
  void set_has_requploadappbehaviour();
  void set_has_reqsubscribetickerdata();
  void set_has_reqsubscribetradedata();
  void set_has_reqsubscribecandlestickupdate();
  void set_has_reqcandlestickquery();
  void set_has_reqtraderule();
  void set_has_reqselfselectedsymbol();
  void set_has_reqmodifystreategysetting();
  void set_has_reqquerystrategyexectioninfo();
  void set_has_reqplaceorder();
  void set_has_reqmodifyorder();
  void set_has_reqcancelorder();
  void set_has_reqonekeycloseposition();
  void set_has_reqqueryactiveorders();
  void set_has_reqqueryhistoricalorders();
  void set_has_reqquerypositions();
  void set_has_reqsetleverage();
  void set_has_reqqueryleverage();
  void set_has_reqqueryleveragebracket();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 25, 25,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Request& from_msg);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* reqaccountsummaryupdate_;
      ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* reqaccountassettransfer_;
      ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* reqqueryassettransferhistory_;
      ::lampyris::crypto::protocol::app::ReqLogin* reqlogin_;
      ::lampyris::crypto::protocol::app::ReqLogout* reqlogout_;
      ::lampyris::crypto::protocol::app::ReqHeartBeat* reqheartbeat_;
      ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* requploadappbehaviour_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* reqsubscribetickerdata_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* reqsubscribetradedata_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* reqsubscribecandlestickupdate_;
      ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* reqcandlestickquery_;
      ::lampyris::crypto::protocol::quote::ReqTradeRule* reqtraderule_;
      ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* reqselfselectedsymbol_;
      ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* reqmodifystreategysetting_;
      ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* reqquerystrategyexectioninfo_;
      ::lampyris::crypto::protocol::trading::ReqPlaceOrder* reqplaceorder_;
      ::lampyris::crypto::protocol::trading::ReqModifyOrder* reqmodifyorder_;
      ::lampyris::crypto::protocol::trading::ReqCancelOrder* reqcancelorder_;
      ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* reqonekeycloseposition_;
      ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* reqqueryactiveorders_;
      ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* reqqueryhistoricalorders_;
      ::lampyris::crypto::protocol::trading::ReqQueryPositions* reqquerypositions_;
      ::lampyris::crypto::protocol::trading::ReqSetLeverage* reqsetleverage_;
      ::lampyris::crypto::protocol::trading::ReqQueryLeverage* reqqueryleverage_;
      ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* reqqueryleveragebracket_;
    } request_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Response final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Response* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Response));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response(
      ::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from) : Response(nullptr, from) {}
  inline Response(Response&& from) noexcept
      : Response(nullptr, std::move(from)) {}
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kAccountAssetInfoBean = 1,
    kSubAccountInfoBean = 2,
    kResQuerySubAcccountList = 3,
    kResAccountSummaryUpdate = 4,
    kAssetTransferHistoryInfoDetailBean = 5,
    kAssetTransferHistoryInfoBean = 6,
    kResLogin = 7,
    kResHeartBeat = 8,
    kResNotice = 9,
    kSymbolTickerDataBean = 10,
    kResSubscribeTickerData = 11,
    kSymbolTradeDataBean = 12,
    kTradeDataBean = 13,
    kResCandlestickQuery = 14,
    kCandlestickUpdateBean = 15,
    kCandlestickBean = 16,
    kResTradeRule = 17,
    kSymbolTradeRuleBean = 18,
    kMarketMonitorNoticeListBean = 19,
    kMarketMonitorNoticeBean = 20,
    kSelfSelectedSymbolInfoBean = 21,
    kSelfSelectedSymbolGroupBean = 22,
    kResSelfSelectedSymbol = 23,
    kMarketPreviewIntervalDataBean = 24,
    kResMarketPreviewData = 25,
    kStreategyConfigBean = 26,
    kStreategyFieldBean = 27,
    kResModifyStreategySetting = 28,
    kResStreategySettings = 29,
    kStrategyExectionInfoBean = 30,
    kResQueryStrategyExectionInfo = 31,
    kConditionTriggerBean = 32,
    kOrderBean = 33,
    kOrderStatusBean = 34,
    kResQueryOrders = 35,
    kPositionBean = 36,
    kResQueryPositions = 37,
    kLeverageBean = 38,
    kResQueryLeverage = 39,
    kResQueryLeverageBracket = 40,
    kSymbolLeverageBracketBean = 41,
    kLeverageBracketBean = 42,
    RESPONSE_TYPE_NOT_SET = 0,
  };
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
        &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Response& a, Response& b) { a.Swap(&b); }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Response& from) { Response::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Response* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Response"; }

 protected:
  explicit Response(::google::protobuf::Arena* arena);
  Response(::google::protobuf::Arena* arena, const Response& from);
  Response(::google::protobuf::Arena* arena, Response&& from) noexcept
      : Response(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountAssetInfoBeanFieldNumber = 1,
    kSubAccountInfoBeanFieldNumber = 2,
    kResQuerySubAcccountListFieldNumber = 3,
    kResAccountSummaryUpdateFieldNumber = 4,
    kAssetTransferHistoryInfoDetailBeanFieldNumber = 5,
    kAssetTransferHistoryInfoBeanFieldNumber = 6,
    kResLoginFieldNumber = 7,
    kResHeartBeatFieldNumber = 8,
    kResNoticeFieldNumber = 9,
    kSymbolTickerDataBeanFieldNumber = 10,
    kResSubscribeTickerDataFieldNumber = 11,
    kSymbolTradeDataBeanFieldNumber = 12,
    kTradeDataBeanFieldNumber = 13,
    kResCandlestickQueryFieldNumber = 14,
    kCandlestickUpdateBeanFieldNumber = 15,
    kCandlestickBeanFieldNumber = 16,
    kResTradeRuleFieldNumber = 17,
    kSymbolTradeRuleBeanFieldNumber = 18,
    kMarketMonitorNoticeListBeanFieldNumber = 19,
    kMarketMonitorNoticeBeanFieldNumber = 20,
    kSelfSelectedSymbolInfoBeanFieldNumber = 21,
    kSelfSelectedSymbolGroupBeanFieldNumber = 22,
    kResSelfSelectedSymbolFieldNumber = 23,
    kMarketPreviewIntervalDataBeanFieldNumber = 24,
    kResMarketPreviewDataFieldNumber = 25,
    kStreategyConfigBeanFieldNumber = 26,
    kStreategyFieldBeanFieldNumber = 27,
    kResModifyStreategySettingFieldNumber = 28,
    kResStreategySettingsFieldNumber = 29,
    kStrategyExectionInfoBeanFieldNumber = 30,
    kResQueryStrategyExectionInfoFieldNumber = 31,
    kConditionTriggerBeanFieldNumber = 32,
    kOrderBeanFieldNumber = 33,
    kOrderStatusBeanFieldNumber = 34,
    kResQueryOrdersFieldNumber = 35,
    kPositionBeanFieldNumber = 36,
    kResQueryPositionsFieldNumber = 37,
    kLeverageBeanFieldNumber = 38,
    kResQueryLeverageFieldNumber = 39,
    kResQueryLeverageBracketFieldNumber = 40,
    kSymbolLeverageBracketBeanFieldNumber = 41,
    kLeverageBracketBeanFieldNumber = 42,
  };
  // .lampyris.crypto.protocol.account.AccountAssetInfoBean accountAssetInfoBean = 1;
  bool has_accountassetinfobean() const;
  private:
  bool _internal_has_accountassetinfobean() const;

  public:
  void clear_accountassetinfobean() ;
  const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& accountassetinfobean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::AccountAssetInfoBean* release_accountassetinfobean();
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* mutable_accountassetinfobean();
  void set_allocated_accountassetinfobean(::lampyris::crypto::protocol::account::AccountAssetInfoBean* value);
  void unsafe_arena_set_allocated_accountassetinfobean(::lampyris::crypto::protocol::account::AccountAssetInfoBean* value);
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* unsafe_arena_release_accountassetinfobean();

  private:
  const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& _internal_accountassetinfobean() const;
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* _internal_mutable_accountassetinfobean();

  public:
  // .lampyris.crypto.protocol.account.SubAccountInfoBean subAccountInfoBean = 2;
  bool has_subaccountinfobean() const;
  private:
  bool _internal_has_subaccountinfobean() const;

  public:
  void clear_subaccountinfobean() ;
  const ::lampyris::crypto::protocol::account::SubAccountInfoBean& subaccountinfobean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::SubAccountInfoBean* release_subaccountinfobean();
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* mutable_subaccountinfobean();
  void set_allocated_subaccountinfobean(::lampyris::crypto::protocol::account::SubAccountInfoBean* value);
  void unsafe_arena_set_allocated_subaccountinfobean(::lampyris::crypto::protocol::account::SubAccountInfoBean* value);
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* unsafe_arena_release_subaccountinfobean();

  private:
  const ::lampyris::crypto::protocol::account::SubAccountInfoBean& _internal_subaccountinfobean() const;
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* _internal_mutable_subaccountinfobean();

  public:
  // .lampyris.crypto.protocol.account.ResQuerySubAcccountList resQuerySubAcccountList = 3;
  bool has_resquerysubacccountlist() const;
  private:
  bool _internal_has_resquerysubacccountlist() const;

  public:
  void clear_resquerysubacccountlist() ;
  const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& resquerysubacccountlist() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* release_resquerysubacccountlist();
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* mutable_resquerysubacccountlist();
  void set_allocated_resquerysubacccountlist(::lampyris::crypto::protocol::account::ResQuerySubAcccountList* value);
  void unsafe_arena_set_allocated_resquerysubacccountlist(::lampyris::crypto::protocol::account::ResQuerySubAcccountList* value);
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* unsafe_arena_release_resquerysubacccountlist();

  private:
  const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& _internal_resquerysubacccountlist() const;
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* _internal_mutable_resquerysubacccountlist();

  public:
  // .lampyris.crypto.protocol.account.ResAccountSummaryUpdate resAccountSummaryUpdate = 4;
  bool has_resaccountsummaryupdate() const;
  private:
  bool _internal_has_resaccountsummaryupdate() const;

  public:
  void clear_resaccountsummaryupdate() ;
  const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& resaccountsummaryupdate() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* release_resaccountsummaryupdate();
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* mutable_resaccountsummaryupdate();
  void set_allocated_resaccountsummaryupdate(::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* value);
  void unsafe_arena_set_allocated_resaccountsummaryupdate(::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* value);
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* unsafe_arena_release_resaccountsummaryupdate();

  private:
  const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& _internal_resaccountsummaryupdate() const;
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* _internal_mutable_resaccountsummaryupdate();

  public:
  // .lampyris.crypto.protocol.account.AssetTransferHistoryInfoDetailBean assetTransferHistoryInfoDetailBean = 5;
  bool has_assettransferhistoryinfodetailbean() const;
  private:
  bool _internal_has_assettransferhistoryinfodetailbean() const;

  public:
  void clear_assettransferhistoryinfodetailbean() ;
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& assettransferhistoryinfodetailbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* release_assettransferhistoryinfodetailbean();
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* mutable_assettransferhistoryinfodetailbean();
  void set_allocated_assettransferhistoryinfodetailbean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* value);
  void unsafe_arena_set_allocated_assettransferhistoryinfodetailbean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* value);
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* unsafe_arena_release_assettransferhistoryinfodetailbean();

  private:
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& _internal_assettransferhistoryinfodetailbean() const;
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* _internal_mutable_assettransferhistoryinfodetailbean();

  public:
  // .lampyris.crypto.protocol.account.AssetTransferHistoryInfoBean assetTransferHistoryInfoBean = 6;
  bool has_assettransferhistoryinfobean() const;
  private:
  bool _internal_has_assettransferhistoryinfobean() const;

  public:
  void clear_assettransferhistoryinfobean() ;
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& assettransferhistoryinfobean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* release_assettransferhistoryinfobean();
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* mutable_assettransferhistoryinfobean();
  void set_allocated_assettransferhistoryinfobean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* value);
  void unsafe_arena_set_allocated_assettransferhistoryinfobean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* value);
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* unsafe_arena_release_assettransferhistoryinfobean();

  private:
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& _internal_assettransferhistoryinfobean() const;
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* _internal_mutable_assettransferhistoryinfobean();

  public:
  // .lampyris.crypto.protocol.app.ResLogin resLogin = 7;
  bool has_reslogin() const;
  private:
  bool _internal_has_reslogin() const;

  public:
  void clear_reslogin() ;
  const ::lampyris::crypto::protocol::app::ResLogin& reslogin() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResLogin* release_reslogin();
  ::lampyris::crypto::protocol::app::ResLogin* mutable_reslogin();
  void set_allocated_reslogin(::lampyris::crypto::protocol::app::ResLogin* value);
  void unsafe_arena_set_allocated_reslogin(::lampyris::crypto::protocol::app::ResLogin* value);
  ::lampyris::crypto::protocol::app::ResLogin* unsafe_arena_release_reslogin();

  private:
  const ::lampyris::crypto::protocol::app::ResLogin& _internal_reslogin() const;
  ::lampyris::crypto::protocol::app::ResLogin* _internal_mutable_reslogin();

  public:
  // .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 8;
  bool has_resheartbeat() const;
  private:
  bool _internal_has_resheartbeat() const;

  public:
  void clear_resheartbeat() ;
  const ::lampyris::crypto::protocol::app::ResHeartBeat& resheartbeat() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResHeartBeat* release_resheartbeat();
  ::lampyris::crypto::protocol::app::ResHeartBeat* mutable_resheartbeat();
  void set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value);
  void unsafe_arena_set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value);
  ::lampyris::crypto::protocol::app::ResHeartBeat* unsafe_arena_release_resheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ResHeartBeat& _internal_resheartbeat() const;
  ::lampyris::crypto::protocol::app::ResHeartBeat* _internal_mutable_resheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ResNotice resNotice = 9;
  bool has_resnotice() const;
  private:
  bool _internal_has_resnotice() const;

  public:
  void clear_resnotice() ;
  const ::lampyris::crypto::protocol::app::ResNotice& resnotice() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResNotice* release_resnotice();
  ::lampyris::crypto::protocol::app::ResNotice* mutable_resnotice();
  void set_allocated_resnotice(::lampyris::crypto::protocol::app::ResNotice* value);
  void unsafe_arena_set_allocated_resnotice(::lampyris::crypto::protocol::app::ResNotice* value);
  ::lampyris::crypto::protocol::app::ResNotice* unsafe_arena_release_resnotice();

  private:
  const ::lampyris::crypto::protocol::app::ResNotice& _internal_resnotice() const;
  ::lampyris::crypto::protocol::app::ResNotice* _internal_mutable_resnotice();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTickerDataBean symbolTickerDataBean = 10;
  bool has_symboltickerdatabean() const;
  private:
  bool _internal_has_symboltickerdatabean() const;

  public:
  void clear_symboltickerdatabean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& symboltickerdatabean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* release_symboltickerdatabean();
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* mutable_symboltickerdatabean();
  void set_allocated_symboltickerdatabean(::lampyris::crypto::protocol::quote::SymbolTickerDataBean* value);
  void unsafe_arena_set_allocated_symboltickerdatabean(::lampyris::crypto::protocol::quote::SymbolTickerDataBean* value);
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* unsafe_arena_release_symboltickerdatabean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& _internal_symboltickerdatabean() const;
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* _internal_mutable_symboltickerdatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 11;
  bool has_ressubscribetickerdata() const;
  private:
  bool _internal_has_ressubscribetickerdata() const;

  public:
  void clear_ressubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& ressubscribetickerdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* release_ressubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* mutable_ressubscribetickerdata();
  void set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value);
  void unsafe_arena_set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value);
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* unsafe_arena_release_ressubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& _internal_ressubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* _internal_mutable_ressubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTradeDataBean symbolTradeDataBean = 12;
  bool has_symboltradedatabean() const;
  private:
  bool _internal_has_symboltradedatabean() const;

  public:
  void clear_symboltradedatabean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& symboltradedatabean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* release_symboltradedatabean();
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* mutable_symboltradedatabean();
  void set_allocated_symboltradedatabean(::lampyris::crypto::protocol::quote::SymbolTradeDataBean* value);
  void unsafe_arena_set_allocated_symboltradedatabean(::lampyris::crypto::protocol::quote::SymbolTradeDataBean* value);
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* unsafe_arena_release_symboltradedatabean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& _internal_symboltradedatabean() const;
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* _internal_mutable_symboltradedatabean();

  public:
  // .lampyris.crypto.protocol.quote.TradeDataBean tradeDataBean = 13;
  bool has_tradedatabean() const;
  private:
  bool _internal_has_tradedatabean() const;

  public:
  void clear_tradedatabean() ;
  const ::lampyris::crypto::protocol::quote::TradeDataBean& tradedatabean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::TradeDataBean* release_tradedatabean();
  ::lampyris::crypto::protocol::quote::TradeDataBean* mutable_tradedatabean();
  void set_allocated_tradedatabean(::lampyris::crypto::protocol::quote::TradeDataBean* value);
  void unsafe_arena_set_allocated_tradedatabean(::lampyris::crypto::protocol::quote::TradeDataBean* value);
  ::lampyris::crypto::protocol::quote::TradeDataBean* unsafe_arena_release_tradedatabean();

  private:
  const ::lampyris::crypto::protocol::quote::TradeDataBean& _internal_tradedatabean() const;
  ::lampyris::crypto::protocol::quote::TradeDataBean* _internal_mutable_tradedatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 14;
  bool has_rescandlestickquery() const;
  private:
  bool _internal_has_rescandlestickquery() const;

  public:
  void clear_rescandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& rescandlestickquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResCandlestickQuery* release_rescandlestickquery();
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* mutable_rescandlestickquery();
  void set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value);
  void unsafe_arena_set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value);
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* unsafe_arena_release_rescandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& _internal_rescandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* _internal_mutable_rescandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.CandlestickUpdateBean candlestickUpdateBean = 15;
  bool has_candlestickupdatebean() const;
  private:
  bool _internal_has_candlestickupdatebean() const;

  public:
  void clear_candlestickupdatebean() ;
  const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& candlestickupdatebean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* release_candlestickupdatebean();
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* mutable_candlestickupdatebean();
  void set_allocated_candlestickupdatebean(::lampyris::crypto::protocol::quote::CandlestickUpdateBean* value);
  void unsafe_arena_set_allocated_candlestickupdatebean(::lampyris::crypto::protocol::quote::CandlestickUpdateBean* value);
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* unsafe_arena_release_candlestickupdatebean();

  private:
  const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& _internal_candlestickupdatebean() const;
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* _internal_mutable_candlestickupdatebean();

  public:
  // .lampyris.crypto.protocol.quote.CandlestickBean candlestickBean = 16;
  bool has_candlestickbean() const;
  private:
  bool _internal_has_candlestickbean() const;

  public:
  void clear_candlestickbean() ;
  const ::lampyris::crypto::protocol::quote::CandlestickBean& candlestickbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::CandlestickBean* release_candlestickbean();
  ::lampyris::crypto::protocol::quote::CandlestickBean* mutable_candlestickbean();
  void set_allocated_candlestickbean(::lampyris::crypto::protocol::quote::CandlestickBean* value);
  void unsafe_arena_set_allocated_candlestickbean(::lampyris::crypto::protocol::quote::CandlestickBean* value);
  ::lampyris::crypto::protocol::quote::CandlestickBean* unsafe_arena_release_candlestickbean();

  private:
  const ::lampyris::crypto::protocol::quote::CandlestickBean& _internal_candlestickbean() const;
  ::lampyris::crypto::protocol::quote::CandlestickBean* _internal_mutable_candlestickbean();

  public:
  // .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 17;
  bool has_restraderule() const;
  private:
  bool _internal_has_restraderule() const;

  public:
  void clear_restraderule() ;
  const ::lampyris::crypto::protocol::quote::ResTradeRule& restraderule() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResTradeRule* release_restraderule();
  ::lampyris::crypto::protocol::quote::ResTradeRule* mutable_restraderule();
  void set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value);
  void unsafe_arena_set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value);
  ::lampyris::crypto::protocol::quote::ResTradeRule* unsafe_arena_release_restraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ResTradeRule& _internal_restraderule() const;
  ::lampyris::crypto::protocol::quote::ResTradeRule* _internal_mutable_restraderule();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTradeRuleBean symbolTradeRuleBean = 18;
  bool has_symboltraderulebean() const;
  private:
  bool _internal_has_symboltraderulebean() const;

  public:
  void clear_symboltraderulebean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& symboltraderulebean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* release_symboltraderulebean();
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* mutable_symboltraderulebean();
  void set_allocated_symboltraderulebean(::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* value);
  void unsafe_arena_set_allocated_symboltraderulebean(::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* value);
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* unsafe_arena_release_symboltraderulebean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& _internal_symboltraderulebean() const;
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* _internal_mutable_symboltraderulebean();

  public:
  // .lampyris.crypto.protocol.quote.MarketMonitorNoticeListBean marketMonitorNoticeListBean = 19;
  bool has_marketmonitornoticelistbean() const;
  private:
  bool _internal_has_marketmonitornoticelistbean() const;

  public:
  void clear_marketmonitornoticelistbean() ;
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& marketmonitornoticelistbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* release_marketmonitornoticelistbean();
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* mutable_marketmonitornoticelistbean();
  void set_allocated_marketmonitornoticelistbean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* value);
  void unsafe_arena_set_allocated_marketmonitornoticelistbean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* value);
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* unsafe_arena_release_marketmonitornoticelistbean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& _internal_marketmonitornoticelistbean() const;
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* _internal_mutable_marketmonitornoticelistbean();

  public:
  // .lampyris.crypto.protocol.quote.MarketMonitorNoticeBean marketMonitorNoticeBean = 20;
  bool has_marketmonitornoticebean() const;
  private:
  bool _internal_has_marketmonitornoticebean() const;

  public:
  void clear_marketmonitornoticebean() ;
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& marketmonitornoticebean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* release_marketmonitornoticebean();
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* mutable_marketmonitornoticebean();
  void set_allocated_marketmonitornoticebean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* value);
  void unsafe_arena_set_allocated_marketmonitornoticebean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* value);
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* unsafe_arena_release_marketmonitornoticebean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& _internal_marketmonitornoticebean() const;
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* _internal_mutable_marketmonitornoticebean();

  public:
  // .lampyris.crypto.protocol.quote.SelfSelectedSymbolInfoBean selfSelectedSymbolInfoBean = 21;
  bool has_selfselectedsymbolinfobean() const;
  private:
  bool _internal_has_selfselectedsymbolinfobean() const;

  public:
  void clear_selfselectedsymbolinfobean() ;
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& selfselectedsymbolinfobean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* release_selfselectedsymbolinfobean();
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* mutable_selfselectedsymbolinfobean();
  void set_allocated_selfselectedsymbolinfobean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* value);
  void unsafe_arena_set_allocated_selfselectedsymbolinfobean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* value);
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* unsafe_arena_release_selfselectedsymbolinfobean();

  private:
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& _internal_selfselectedsymbolinfobean() const;
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* _internal_mutable_selfselectedsymbolinfobean();

  public:
  // .lampyris.crypto.protocol.quote.SelfSelectedSymbolGroupBean selfSelectedSymbolGroupBean = 22;
  bool has_selfselectedsymbolgroupbean() const;
  private:
  bool _internal_has_selfselectedsymbolgroupbean() const;

  public:
  void clear_selfselectedsymbolgroupbean() ;
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& selfselectedsymbolgroupbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* release_selfselectedsymbolgroupbean();
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* mutable_selfselectedsymbolgroupbean();
  void set_allocated_selfselectedsymbolgroupbean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* value);
  void unsafe_arena_set_allocated_selfselectedsymbolgroupbean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* value);
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* unsafe_arena_release_selfselectedsymbolgroupbean();

  private:
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& _internal_selfselectedsymbolgroupbean() const;
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* _internal_mutable_selfselectedsymbolgroupbean();

  public:
  // .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 23;
  bool has_resselfselectedsymbol() const;
  private:
  bool _internal_has_resselfselectedsymbol() const;

  public:
  void clear_resselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& resselfselectedsymbol() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* release_resselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* mutable_resselfselectedsymbol();
  void set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value);
  void unsafe_arena_set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value);
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* unsafe_arena_release_resselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& _internal_resselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* _internal_mutable_resselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.quote.MarketPreviewIntervalDataBean marketPreviewIntervalDataBean = 24;
  bool has_marketpreviewintervaldatabean() const;
  private:
  bool _internal_has_marketpreviewintervaldatabean() const;

  public:
  void clear_marketpreviewintervaldatabean() ;
  const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& marketpreviewintervaldatabean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* release_marketpreviewintervaldatabean();
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* mutable_marketpreviewintervaldatabean();
  void set_allocated_marketpreviewintervaldatabean(::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* value);
  void unsafe_arena_set_allocated_marketpreviewintervaldatabean(::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* value);
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* unsafe_arena_release_marketpreviewintervaldatabean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& _internal_marketpreviewintervaldatabean() const;
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* _internal_mutable_marketpreviewintervaldatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 25;
  bool has_resmarketpreviewdata() const;
  private:
  bool _internal_has_resmarketpreviewdata() const;

  public:
  void clear_resmarketpreviewdata() ;
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& resmarketpreviewdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResMarketPreviewData* release_resmarketpreviewdata();
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* mutable_resmarketpreviewdata();
  void set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value);
  void unsafe_arena_set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value);
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* unsafe_arena_release_resmarketpreviewdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& _internal_resmarketpreviewdata() const;
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* _internal_mutable_resmarketpreviewdata();

  public:
  // .lampyris.crypto.protocol.strategy.StreategyConfigBean streategyConfigBean = 26;
  bool has_streategyconfigbean() const;
  private:
  bool _internal_has_streategyconfigbean() const;

  public:
  void clear_streategyconfigbean() ;
  const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& streategyconfigbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StreategyConfigBean* release_streategyconfigbean();
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* mutable_streategyconfigbean();
  void set_allocated_streategyconfigbean(::lampyris::crypto::protocol::strategy::StreategyConfigBean* value);
  void unsafe_arena_set_allocated_streategyconfigbean(::lampyris::crypto::protocol::strategy::StreategyConfigBean* value);
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* unsafe_arena_release_streategyconfigbean();

  private:
  const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& _internal_streategyconfigbean() const;
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* _internal_mutable_streategyconfigbean();

  public:
  // .lampyris.crypto.protocol.strategy.StreategyFieldBean streategyFieldBean = 27;
  bool has_streategyfieldbean() const;
  private:
  bool _internal_has_streategyfieldbean() const;

  public:
  void clear_streategyfieldbean() ;
  const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& streategyfieldbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StreategyFieldBean* release_streategyfieldbean();
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* mutable_streategyfieldbean();
  void set_allocated_streategyfieldbean(::lampyris::crypto::protocol::strategy::StreategyFieldBean* value);
  void unsafe_arena_set_allocated_streategyfieldbean(::lampyris::crypto::protocol::strategy::StreategyFieldBean* value);
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* unsafe_arena_release_streategyfieldbean();

  private:
  const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& _internal_streategyfieldbean() const;
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* _internal_mutable_streategyfieldbean();

  public:
  // .lampyris.crypto.protocol.strategy.ResModifyStreategySetting resModifyStreategySetting = 28;
  bool has_resmodifystreategysetting() const;
  private:
  bool _internal_has_resmodifystreategysetting() const;

  public:
  void clear_resmodifystreategysetting() ;
  const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& resmodifystreategysetting() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* release_resmodifystreategysetting();
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* mutable_resmodifystreategysetting();
  void set_allocated_resmodifystreategysetting(::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* value);
  void unsafe_arena_set_allocated_resmodifystreategysetting(::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* value);
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* unsafe_arena_release_resmodifystreategysetting();

  private:
  const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& _internal_resmodifystreategysetting() const;
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* _internal_mutable_resmodifystreategysetting();

  public:
  // .lampyris.crypto.protocol.strategy.ResStreategySettings resStreategySettings = 29;
  bool has_resstreategysettings() const;
  private:
  bool _internal_has_resstreategysettings() const;

  public:
  void clear_resstreategysettings() ;
  const ::lampyris::crypto::protocol::strategy::ResStreategySettings& resstreategysettings() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStreategySettings* release_resstreategysettings();
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* mutable_resstreategysettings();
  void set_allocated_resstreategysettings(::lampyris::crypto::protocol::strategy::ResStreategySettings* value);
  void unsafe_arena_set_allocated_resstreategysettings(::lampyris::crypto::protocol::strategy::ResStreategySettings* value);
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* unsafe_arena_release_resstreategysettings();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStreategySettings& _internal_resstreategysettings() const;
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* _internal_mutable_resstreategysettings();

  public:
  // .lampyris.crypto.protocol.strategy.StrategyExectionInfoBean strategyExectionInfoBean = 30;
  bool has_strategyexectioninfobean() const;
  private:
  bool _internal_has_strategyexectioninfobean() const;

  public:
  void clear_strategyexectioninfobean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& strategyexectioninfobean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* release_strategyexectioninfobean();
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* mutable_strategyexectioninfobean();
  void set_allocated_strategyexectioninfobean(::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* value);
  void unsafe_arena_set_allocated_strategyexectioninfobean(::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* value);
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* unsafe_arena_release_strategyexectioninfobean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& _internal_strategyexectioninfobean() const;
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* _internal_mutable_strategyexectioninfobean();

  public:
  // .lampyris.crypto.protocol.strategy.ResQueryStrategyExectionInfo resQueryStrategyExectionInfo = 31;
  bool has_resquerystrategyexectioninfo() const;
  private:
  bool _internal_has_resquerystrategyexectioninfo() const;

  public:
  void clear_resquerystrategyexectioninfo() ;
  const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& resquerystrategyexectioninfo() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* release_resquerystrategyexectioninfo();
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* mutable_resquerystrategyexectioninfo();
  void set_allocated_resquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* value);
  void unsafe_arena_set_allocated_resquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* value);
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* unsafe_arena_release_resquerystrategyexectioninfo();

  private:
  const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& _internal_resquerystrategyexectioninfo() const;
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* _internal_mutable_resquerystrategyexectioninfo();

  public:
  // .lampyris.crypto.protocol.trading.ConditionTriggerBean conditionTriggerBean = 32;
  bool has_conditiontriggerbean() const;
  private:
  bool _internal_has_conditiontriggerbean() const;

  public:
  void clear_conditiontriggerbean() ;
  const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& conditiontriggerbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ConditionTriggerBean* release_conditiontriggerbean();
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* mutable_conditiontriggerbean();
  void set_allocated_conditiontriggerbean(::lampyris::crypto::protocol::trading::ConditionTriggerBean* value);
  void unsafe_arena_set_allocated_conditiontriggerbean(::lampyris::crypto::protocol::trading::ConditionTriggerBean* value);
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* unsafe_arena_release_conditiontriggerbean();

  private:
  const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& _internal_conditiontriggerbean() const;
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* _internal_mutable_conditiontriggerbean();

  public:
  // .lampyris.crypto.protocol.trading.OrderBean orderBean = 33;
  bool has_orderbean() const;
  private:
  bool _internal_has_orderbean() const;

  public:
  void clear_orderbean() ;
  const ::lampyris::crypto::protocol::trading::OrderBean& orderbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::OrderBean* release_orderbean();
  ::lampyris::crypto::protocol::trading::OrderBean* mutable_orderbean();
  void set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  void unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  ::lampyris::crypto::protocol::trading::OrderBean* unsafe_arena_release_orderbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderBean& _internal_orderbean() const;
  ::lampyris::crypto::protocol::trading::OrderBean* _internal_mutable_orderbean();

  public:
  // .lampyris.crypto.protocol.trading.OrderStatusBean orderStatusBean = 34;
  bool has_orderstatusbean() const;
  private:
  bool _internal_has_orderstatusbean() const;

  public:
  void clear_orderstatusbean() ;
  const ::lampyris::crypto::protocol::trading::OrderStatusBean& orderstatusbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::OrderStatusBean* release_orderstatusbean();
  ::lampyris::crypto::protocol::trading::OrderStatusBean* mutable_orderstatusbean();
  void set_allocated_orderstatusbean(::lampyris::crypto::protocol::trading::OrderStatusBean* value);
  void unsafe_arena_set_allocated_orderstatusbean(::lampyris::crypto::protocol::trading::OrderStatusBean* value);
  ::lampyris::crypto::protocol::trading::OrderStatusBean* unsafe_arena_release_orderstatusbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderStatusBean& _internal_orderstatusbean() const;
  ::lampyris::crypto::protocol::trading::OrderStatusBean* _internal_mutable_orderstatusbean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 35;
  bool has_resqueryorders() const;
  private:
  bool _internal_has_resqueryorders() const;

  public:
  void clear_resqueryorders() ;
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& resqueryorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryOrders* release_resqueryorders();
  ::lampyris::crypto::protocol::trading::ResQueryOrders* mutable_resqueryorders();
  void set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value);
  void unsafe_arena_set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value);
  ::lampyris::crypto::protocol::trading::ResQueryOrders* unsafe_arena_release_resqueryorders();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& _internal_resqueryorders() const;
  ::lampyris::crypto::protocol::trading::ResQueryOrders* _internal_mutable_resqueryorders();

  public:
  // .lampyris.crypto.protocol.trading.PositionBean positionBean = 36;
  bool has_positionbean() const;
  private:
  bool _internal_has_positionbean() const;

  public:
  void clear_positionbean() ;
  const ::lampyris::crypto::protocol::trading::PositionBean& positionbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::PositionBean* release_positionbean();
  ::lampyris::crypto::protocol::trading::PositionBean* mutable_positionbean();
  void set_allocated_positionbean(::lampyris::crypto::protocol::trading::PositionBean* value);
  void unsafe_arena_set_allocated_positionbean(::lampyris::crypto::protocol::trading::PositionBean* value);
  ::lampyris::crypto::protocol::trading::PositionBean* unsafe_arena_release_positionbean();

  private:
  const ::lampyris::crypto::protocol::trading::PositionBean& _internal_positionbean() const;
  ::lampyris::crypto::protocol::trading::PositionBean* _internal_mutable_positionbean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 37;
  bool has_resquerypositions() const;
  private:
  bool _internal_has_resquerypositions() const;

  public:
  void clear_resquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& resquerypositions() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryPositions* release_resquerypositions();
  ::lampyris::crypto::protocol::trading::ResQueryPositions* mutable_resquerypositions();
  void set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value);
  void unsafe_arena_set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value);
  ::lampyris::crypto::protocol::trading::ResQueryPositions* unsafe_arena_release_resquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& _internal_resquerypositions() const;
  ::lampyris::crypto::protocol::trading::ResQueryPositions* _internal_mutable_resquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.LeverageBean leverageBean = 38;
  bool has_leveragebean() const;
  private:
  bool _internal_has_leveragebean() const;

  public:
  void clear_leveragebean() ;
  const ::lampyris::crypto::protocol::trading::LeverageBean& leveragebean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::LeverageBean* release_leveragebean();
  ::lampyris::crypto::protocol::trading::LeverageBean* mutable_leveragebean();
  void set_allocated_leveragebean(::lampyris::crypto::protocol::trading::LeverageBean* value);
  void unsafe_arena_set_allocated_leveragebean(::lampyris::crypto::protocol::trading::LeverageBean* value);
  ::lampyris::crypto::protocol::trading::LeverageBean* unsafe_arena_release_leveragebean();

  private:
  const ::lampyris::crypto::protocol::trading::LeverageBean& _internal_leveragebean() const;
  ::lampyris::crypto::protocol::trading::LeverageBean* _internal_mutable_leveragebean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 39;
  bool has_resqueryleverage() const;
  private:
  bool _internal_has_resqueryleverage() const;

  public:
  void clear_resqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& resqueryleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryLeverage* release_resqueryleverage();
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* mutable_resqueryleverage();
  void set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value);
  void unsafe_arena_set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* unsafe_arena_release_resqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& _internal_resqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* _internal_mutable_resqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 40;
  bool has_resqueryleveragebracket() const;
  private:
  bool _internal_has_resqueryleveragebracket() const;

  public:
  void clear_resqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& resqueryleveragebracket() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* release_resqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* mutable_resqueryleveragebracket();
  void set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value);
  void unsafe_arena_set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* unsafe_arena_release_resqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& _internal_resqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* _internal_mutable_resqueryleveragebracket();

  public:
  // .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean symbolLeverageBracketBean = 41;
  bool has_symbolleveragebracketbean() const;
  private:
  bool _internal_has_symbolleveragebracketbean() const;

  public:
  void clear_symbolleveragebracketbean() ;
  const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& symbolleveragebracketbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* release_symbolleveragebracketbean();
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* mutable_symbolleveragebracketbean();
  void set_allocated_symbolleveragebracketbean(::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* value);
  void unsafe_arena_set_allocated_symbolleveragebracketbean(::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* value);
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* unsafe_arena_release_symbolleveragebracketbean();

  private:
  const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& _internal_symbolleveragebracketbean() const;
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* _internal_mutable_symbolleveragebracketbean();

  public:
  // .lampyris.crypto.protocol.trading.LeverageBracketBean leverageBracketBean = 42;
  bool has_leveragebracketbean() const;
  private:
  bool _internal_has_leveragebracketbean() const;

  public:
  void clear_leveragebracketbean() ;
  const ::lampyris::crypto::protocol::trading::LeverageBracketBean& leveragebracketbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::LeverageBracketBean* release_leveragebracketbean();
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* mutable_leveragebracketbean();
  void set_allocated_leveragebracketbean(::lampyris::crypto::protocol::trading::LeverageBracketBean* value);
  void unsafe_arena_set_allocated_leveragebracketbean(::lampyris::crypto::protocol::trading::LeverageBracketBean* value);
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* unsafe_arena_release_leveragebracketbean();

  private:
  const ::lampyris::crypto::protocol::trading::LeverageBracketBean& _internal_leveragebracketbean() const;
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* _internal_mutable_leveragebracketbean();

  public:
  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Response)
 private:
  class _Internal;
  void set_has_accountassetinfobean();
  void set_has_subaccountinfobean();
  void set_has_resquerysubacccountlist();
  void set_has_resaccountsummaryupdate();
  void set_has_assettransferhistoryinfodetailbean();
  void set_has_assettransferhistoryinfobean();
  void set_has_reslogin();
  void set_has_resheartbeat();
  void set_has_resnotice();
  void set_has_symboltickerdatabean();
  void set_has_ressubscribetickerdata();
  void set_has_symboltradedatabean();
  void set_has_tradedatabean();
  void set_has_rescandlestickquery();
  void set_has_candlestickupdatebean();
  void set_has_candlestickbean();
  void set_has_restraderule();
  void set_has_symboltraderulebean();
  void set_has_marketmonitornoticelistbean();
  void set_has_marketmonitornoticebean();
  void set_has_selfselectedsymbolinfobean();
  void set_has_selfselectedsymbolgroupbean();
  void set_has_resselfselectedsymbol();
  void set_has_marketpreviewintervaldatabean();
  void set_has_resmarketpreviewdata();
  void set_has_streategyconfigbean();
  void set_has_streategyfieldbean();
  void set_has_resmodifystreategysetting();
  void set_has_resstreategysettings();
  void set_has_strategyexectioninfobean();
  void set_has_resquerystrategyexectioninfo();
  void set_has_conditiontriggerbean();
  void set_has_orderbean();
  void set_has_orderstatusbean();
  void set_has_resqueryorders();
  void set_has_positionbean();
  void set_has_resquerypositions();
  void set_has_leveragebean();
  void set_has_resqueryleverage();
  void set_has_resqueryleveragebracket();
  void set_has_symbolleveragebracketbean();
  void set_has_leveragebracketbean();
  inline bool has_response_type() const;
  inline void clear_has_response_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 42, 42,
      0, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Response& from_msg);
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::lampyris::crypto::protocol::account::AccountAssetInfoBean* accountassetinfobean_;
      ::lampyris::crypto::protocol::account::SubAccountInfoBean* subaccountinfobean_;
      ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* resquerysubacccountlist_;
      ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* resaccountsummaryupdate_;
      ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* assettransferhistoryinfodetailbean_;
      ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* assettransferhistoryinfobean_;
      ::lampyris::crypto::protocol::app::ResLogin* reslogin_;
      ::lampyris::crypto::protocol::app::ResHeartBeat* resheartbeat_;
      ::lampyris::crypto::protocol::app::ResNotice* resnotice_;
      ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* symboltickerdatabean_;
      ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* ressubscribetickerdata_;
      ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* symboltradedatabean_;
      ::lampyris::crypto::protocol::quote::TradeDataBean* tradedatabean_;
      ::lampyris::crypto::protocol::quote::ResCandlestickQuery* rescandlestickquery_;
      ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* candlestickupdatebean_;
      ::lampyris::crypto::protocol::quote::CandlestickBean* candlestickbean_;
      ::lampyris::crypto::protocol::quote::ResTradeRule* restraderule_;
      ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* symboltraderulebean_;
      ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* marketmonitornoticelistbean_;
      ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* marketmonitornoticebean_;
      ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* selfselectedsymbolinfobean_;
      ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* selfselectedsymbolgroupbean_;
      ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* resselfselectedsymbol_;
      ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* marketpreviewintervaldatabean_;
      ::lampyris::crypto::protocol::quote::ResMarketPreviewData* resmarketpreviewdata_;
      ::lampyris::crypto::protocol::strategy::StreategyConfigBean* streategyconfigbean_;
      ::lampyris::crypto::protocol::strategy::StreategyFieldBean* streategyfieldbean_;
      ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* resmodifystreategysetting_;
      ::lampyris::crypto::protocol::strategy::ResStreategySettings* resstreategysettings_;
      ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* strategyexectioninfobean_;
      ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* resquerystrategyexectioninfo_;
      ::lampyris::crypto::protocol::trading::ConditionTriggerBean* conditiontriggerbean_;
      ::lampyris::crypto::protocol::trading::OrderBean* orderbean_;
      ::lampyris::crypto::protocol::trading::OrderStatusBean* orderstatusbean_;
      ::lampyris::crypto::protocol::trading::ResQueryOrders* resqueryorders_;
      ::lampyris::crypto::protocol::trading::PositionBean* positionbean_;
      ::lampyris::crypto::protocol::trading::ResQueryPositions* resquerypositions_;
      ::lampyris::crypto::protocol::trading::LeverageBean* leveragebean_;
      ::lampyris::crypto::protocol::trading::ResQueryLeverage* resqueryleverage_;
      ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* resqueryleveragebracket_;
      ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* symbolleveragebracketbean_;
      ::lampyris::crypto::protocol::trading::LeverageBracketBean* leveragebracketbean_;
    } response_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// .lampyris.crypto.protocol.account.ReqAccountSummaryUpdate reqAccountSummaryUpdate = 1;
inline bool Request::has_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate;
}
inline bool Request::_internal_has_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate;
}
inline void Request::set_has_reqaccountsummaryupdate() {
  _impl_._oneof_case_[0] = kReqAccountSummaryUpdate;
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* Request::release_reqaccountsummaryupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  if (request_type_case() == kReqAccountSummaryUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqaccountsummaryupdate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& Request::_internal_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate ? *_impl_.request_type_.reqaccountsummaryupdate_ : reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate&>(::lampyris::crypto::protocol::account::_ReqAccountSummaryUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& Request::reqaccountsummaryupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  return _internal_reqaccountsummaryupdate();
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* Request::unsafe_arena_release_reqaccountsummaryupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  if (request_type_case() == kReqAccountSummaryUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqaccountsummaryupdate_;
    _impl_.request_type_.reqaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqaccountsummaryupdate(::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqaccountsummaryupdate();
    _impl_.request_type_.reqaccountsummaryupdate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* Request::_internal_mutable_reqaccountsummaryupdate() {
  if (request_type_case() != kReqAccountSummaryUpdate) {
    clear_request_type();
    set_has_reqaccountsummaryupdate();
    _impl_.request_type_.reqaccountsummaryupdate_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate>(GetArena());
  }
  return _impl_.request_type_.reqaccountsummaryupdate_;
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* Request::mutable_reqaccountsummaryupdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* _msg = _internal_mutable_reqaccountsummaryupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.account.ReqAccountAssetTransfer reqAccountAssetTransfer = 2;
inline bool Request::has_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer;
}
inline bool Request::_internal_has_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer;
}
inline void Request::set_has_reqaccountassettransfer() {
  _impl_._oneof_case_[0] = kReqAccountAssetTransfer;
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* Request::release_reqaccountassettransfer() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  if (request_type_case() == kReqAccountAssetTransfer) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqaccountassettransfer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqaccountassettransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& Request::_internal_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer ? *_impl_.request_type_.reqaccountassettransfer_ : reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer&>(::lampyris::crypto::protocol::account::_ReqAccountAssetTransfer_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& Request::reqaccountassettransfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  return _internal_reqaccountassettransfer();
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* Request::unsafe_arena_release_reqaccountassettransfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  if (request_type_case() == kReqAccountAssetTransfer) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqaccountassettransfer_;
    _impl_.request_type_.reqaccountassettransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqaccountassettransfer(::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqaccountassettransfer();
    _impl_.request_type_.reqaccountassettransfer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* Request::_internal_mutable_reqaccountassettransfer() {
  if (request_type_case() != kReqAccountAssetTransfer) {
    clear_request_type();
    set_has_reqaccountassettransfer();
    _impl_.request_type_.reqaccountassettransfer_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer>(GetArena());
  }
  return _impl_.request_type_.reqaccountassettransfer_;
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* Request::mutable_reqaccountassettransfer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* _msg = _internal_mutable_reqaccountassettransfer();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  return _msg;
}

// .lampyris.crypto.protocol.account.ReqQueryAssetTransferHistory reqQueryAssetTransferHistory = 3;
inline bool Request::has_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory;
}
inline bool Request::_internal_has_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory;
}
inline void Request::set_has_reqqueryassettransferhistory() {
  _impl_._oneof_case_[0] = kReqQueryAssetTransferHistory;
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* Request::release_reqqueryassettransferhistory() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  if (request_type_case() == kReqQueryAssetTransferHistory) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryassettransferhistory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryassettransferhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& Request::_internal_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory ? *_impl_.request_type_.reqqueryassettransferhistory_ : reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory&>(::lampyris::crypto::protocol::account::_ReqQueryAssetTransferHistory_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& Request::reqqueryassettransferhistory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  return _internal_reqqueryassettransferhistory();
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* Request::unsafe_arena_release_reqqueryassettransferhistory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  if (request_type_case() == kReqQueryAssetTransferHistory) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryassettransferhistory_;
    _impl_.request_type_.reqqueryassettransferhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryassettransferhistory(::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryassettransferhistory();
    _impl_.request_type_.reqqueryassettransferhistory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* Request::_internal_mutable_reqqueryassettransferhistory() {
  if (request_type_case() != kReqQueryAssetTransferHistory) {
    clear_request_type();
    set_has_reqqueryassettransferhistory();
    _impl_.request_type_.reqqueryassettransferhistory_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory>(GetArena());
  }
  return _impl_.request_type_.reqqueryassettransferhistory_;
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* Request::mutable_reqqueryassettransferhistory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* _msg = _internal_mutable_reqqueryassettransferhistory();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqLogin reqLogin = 4;
inline bool Request::has_reqlogin() const {
  return request_type_case() == kReqLogin;
}
inline bool Request::_internal_has_reqlogin() const {
  return request_type_case() == kReqLogin;
}
inline void Request::set_has_reqlogin() {
  _impl_._oneof_case_[0] = kReqLogin;
}
inline ::lampyris::crypto::protocol::app::ReqLogin* Request::release_reqlogin() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqLogin)
  if (request_type_case() == kReqLogin) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqlogin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqlogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqLogin& Request::_internal_reqlogin() const {
  return request_type_case() == kReqLogin ? *_impl_.request_type_.reqlogin_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin&>(::lampyris::crypto::protocol::app::_ReqLogin_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqLogin& Request::reqlogin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqLogin)
  return _internal_reqlogin();
}
inline ::lampyris::crypto::protocol::app::ReqLogin* Request::unsafe_arena_release_reqlogin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqLogin)
  if (request_type_case() == kReqLogin) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqlogin_;
    _impl_.request_type_.reqlogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqlogin(::lampyris::crypto::protocol::app::ReqLogin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqlogin();
    _impl_.request_type_.reqlogin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqLogin)
}
inline ::lampyris::crypto::protocol::app::ReqLogin* Request::_internal_mutable_reqlogin() {
  if (request_type_case() != kReqLogin) {
    clear_request_type();
    set_has_reqlogin();
    _impl_.request_type_.reqlogin_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqLogin>(GetArena());
  }
  return _impl_.request_type_.reqlogin_;
}
inline ::lampyris::crypto::protocol::app::ReqLogin* Request::mutable_reqlogin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqLogin* _msg = _internal_mutable_reqlogin();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqLogin)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqLogout reqLogout = 5;
inline bool Request::has_reqlogout() const {
  return request_type_case() == kReqLogout;
}
inline bool Request::_internal_has_reqlogout() const {
  return request_type_case() == kReqLogout;
}
inline void Request::set_has_reqlogout() {
  _impl_._oneof_case_[0] = kReqLogout;
}
inline ::lampyris::crypto::protocol::app::ReqLogout* Request::release_reqlogout() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqLogout)
  if (request_type_case() == kReqLogout) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqlogout_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqLogout& Request::_internal_reqlogout() const {
  return request_type_case() == kReqLogout ? *_impl_.request_type_.reqlogout_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout&>(::lampyris::crypto::protocol::app::_ReqLogout_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqLogout& Request::reqlogout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqLogout)
  return _internal_reqlogout();
}
inline ::lampyris::crypto::protocol::app::ReqLogout* Request::unsafe_arena_release_reqlogout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqLogout)
  if (request_type_case() == kReqLogout) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqlogout_;
    _impl_.request_type_.reqlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqlogout(::lampyris::crypto::protocol::app::ReqLogout* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqlogout();
    _impl_.request_type_.reqlogout_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqLogout)
}
inline ::lampyris::crypto::protocol::app::ReqLogout* Request::_internal_mutable_reqlogout() {
  if (request_type_case() != kReqLogout) {
    clear_request_type();
    set_has_reqlogout();
    _impl_.request_type_.reqlogout_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqLogout>(GetArena());
  }
  return _impl_.request_type_.reqlogout_;
}
inline ::lampyris::crypto::protocol::app::ReqLogout* Request::mutable_reqlogout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqLogout* _msg = _internal_mutable_reqlogout();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqLogout)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 6;
inline bool Request::has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline bool Request::_internal_has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline void Request::set_has_reqheartbeat() {
  _impl_._oneof_case_[0] = kReqHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::release_reqheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqheartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::_internal_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat ? *_impl_.request_type_.reqheartbeat_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat&>(::lampyris::crypto::protocol::app::_ReqHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::reqheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _internal_reqheartbeat();
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::unsafe_arena_release_reqheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqheartbeat_;
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::_internal_mutable_reqheartbeat() {
  if (request_type_case() != kReqHeartBeat) {
    clear_request_type();
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqHeartBeat>(GetArena());
  }
  return _impl_.request_type_.reqheartbeat_;
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::mutable_reqheartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqHeartBeat* _msg = _internal_mutable_reqheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqUploadAppBehaviour reqUploadAppBehaviour = 7;
inline bool Request::has_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour;
}
inline bool Request::_internal_has_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour;
}
inline void Request::set_has_requploadappbehaviour() {
  _impl_._oneof_case_[0] = kReqUploadAppBehaviour;
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* Request::release_requploadappbehaviour() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  if (request_type_case() == kReqUploadAppBehaviour) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.requploadappbehaviour_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.requploadappbehaviour_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& Request::_internal_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour ? *_impl_.request_type_.requploadappbehaviour_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour&>(::lampyris::crypto::protocol::app::_ReqUploadAppBehaviour_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& Request::requploadappbehaviour() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  return _internal_requploadappbehaviour();
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* Request::unsafe_arena_release_requploadappbehaviour() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  if (request_type_case() == kReqUploadAppBehaviour) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.requploadappbehaviour_;
    _impl_.request_type_.requploadappbehaviour_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_requploadappbehaviour(::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_requploadappbehaviour();
    _impl_.request_type_.requploadappbehaviour_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* Request::_internal_mutable_requploadappbehaviour() {
  if (request_type_case() != kReqUploadAppBehaviour) {
    clear_request_type();
    set_has_requploadappbehaviour();
    _impl_.request_type_.requploadappbehaviour_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour>(GetArena());
  }
  return _impl_.request_type_.requploadappbehaviour_;
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* Request::mutable_requploadappbehaviour() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* _msg = _internal_mutable_requploadappbehaviour();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 8;
inline bool Request::has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline bool Request::_internal_has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline void Request::set_has_reqsubscribetickerdata() {
  _impl_._oneof_case_[0] = kReqSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetickerdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::_internal_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData ? *_impl_.request_type_.reqsubscribetickerdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::reqsubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _internal_reqsubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::unsafe_arena_release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetickerdata_;
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::_internal_mutable_reqsubscribetickerdata() {
  if (request_type_case() != kReqSubscribeTickerData) {
    clear_request_type();
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData>(GetArena());
  }
  return _impl_.request_type_.reqsubscribetickerdata_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::mutable_reqsubscribetickerdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* _msg = _internal_mutable_reqsubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 9;
inline bool Request::has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline bool Request::_internal_has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline void Request::set_has_reqsubscribetradedata() {
  _impl_._oneof_case_[0] = kReqSubscribeTradeData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetradedata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::_internal_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData ? *_impl_.request_type_.reqsubscribetradedata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTradeData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::reqsubscribetradedata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _internal_reqsubscribetradedata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::unsafe_arena_release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetradedata_;
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::_internal_mutable_reqsubscribetradedata() {
  if (request_type_case() != kReqSubscribeTradeData) {
    clear_request_type();
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData>(GetArena());
  }
  return _impl_.request_type_.reqsubscribetradedata_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::mutable_reqsubscribetradedata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* _msg = _internal_mutable_reqsubscribetradedata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 10;
inline bool Request::has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline bool Request::_internal_has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline void Request::set_has_reqsubscribecandlestickupdate() {
  _impl_._oneof_case_[0] = kReqSubscribeCandlestickUpdate;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribecandlestickupdate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::_internal_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate ? *_impl_.request_type_.reqsubscribecandlestickupdate_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate&>(::lampyris::crypto::protocol::quote::_ReqSubscribeCandlestickUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::reqsubscribecandlestickupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _internal_reqsubscribecandlestickupdate();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::unsafe_arena_release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribecandlestickupdate_;
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::_internal_mutable_reqsubscribecandlestickupdate() {
  if (request_type_case() != kReqSubscribeCandlestickUpdate) {
    clear_request_type();
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate>(GetArena());
  }
  return _impl_.request_type_.reqsubscribecandlestickupdate_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::mutable_reqsubscribecandlestickupdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* _msg = _internal_mutable_reqsubscribecandlestickupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 11;
inline bool Request::has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline bool Request::_internal_has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline void Request::set_has_reqcandlestickquery() {
  _impl_._oneof_case_[0] = kReqCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcandlestickquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::_internal_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery ? *_impl_.request_type_.reqcandlestickquery_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ReqCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::reqcandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _internal_reqcandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::unsafe_arena_release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcandlestickquery_;
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::_internal_mutable_reqcandlestickquery() {
  if (request_type_case() != kReqCandlestickQuery) {
    clear_request_type();
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqCandlestickQuery>(GetArena());
  }
  return _impl_.request_type_.reqcandlestickquery_;
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::mutable_reqcandlestickquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* _msg = _internal_mutable_reqcandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 12;
inline bool Request::has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline bool Request::_internal_has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline void Request::set_has_reqtraderule() {
  _impl_._oneof_case_[0] = kReqTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::release_reqtraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqtraderule_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::_internal_reqtraderule() const {
  return request_type_case() == kReqTradeRule ? *_impl_.request_type_.reqtraderule_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule&>(::lampyris::crypto::protocol::quote::_ReqTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::reqtraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _internal_reqtraderule();
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::unsafe_arena_release_reqtraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqtraderule_;
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::_internal_mutable_reqtraderule() {
  if (request_type_case() != kReqTradeRule) {
    clear_request_type();
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqTradeRule>(GetArena());
  }
  return _impl_.request_type_.reqtraderule_;
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::mutable_reqtraderule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqTradeRule* _msg = _internal_mutable_reqtraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 13;
inline bool Request::has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline bool Request::_internal_has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline void Request::set_has_reqselfselectedsymbol() {
  _impl_._oneof_case_[0] = kReqSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqselfselectedsymbol_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::_internal_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol ? *_impl_.request_type_.reqselfselectedsymbol_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ReqSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::reqselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _internal_reqselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::unsafe_arena_release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqselfselectedsymbol_;
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::_internal_mutable_reqselfselectedsymbol() {
  if (request_type_case() != kReqSelfSelectedSymbol) {
    clear_request_type();
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol>(GetArena());
  }
  return _impl_.request_type_.reqselfselectedsymbol_;
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::mutable_reqselfselectedsymbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* _msg = _internal_mutable_reqselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqModifyStreategySetting reqModifyStreategySetting = 14;
inline bool Request::has_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting;
}
inline bool Request::_internal_has_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting;
}
inline void Request::set_has_reqmodifystreategysetting() {
  _impl_._oneof_case_[0] = kReqModifyStreategySetting;
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* Request::release_reqmodifystreategysetting() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  if (request_type_case() == kReqModifyStreategySetting) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifystreategysetting_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& Request::_internal_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting ? *_impl_.request_type_.reqmodifystreategysetting_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting&>(::lampyris::crypto::protocol::strategy::_ReqModifyStreategySetting_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& Request::reqmodifystreategysetting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  return _internal_reqmodifystreategysetting();
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* Request::unsafe_arena_release_reqmodifystreategysetting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  if (request_type_case() == kReqModifyStreategySetting) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifystreategysetting_;
    _impl_.request_type_.reqmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqmodifystreategysetting(::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqmodifystreategysetting();
    _impl_.request_type_.reqmodifystreategysetting_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* Request::_internal_mutable_reqmodifystreategysetting() {
  if (request_type_case() != kReqModifyStreategySetting) {
    clear_request_type();
    set_has_reqmodifystreategysetting();
    _impl_.request_type_.reqmodifystreategysetting_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting>(GetArena());
  }
  return _impl_.request_type_.reqmodifystreategysetting_;
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* Request::mutable_reqmodifystreategysetting() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* _msg = _internal_mutable_reqmodifystreategysetting();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqQueryStrategyExectionInfo reqQueryStrategyExectionInfo = 15;
inline bool Request::has_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo;
}
inline bool Request::_internal_has_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo;
}
inline void Request::set_has_reqquerystrategyexectioninfo() {
  _impl_._oneof_case_[0] = kReqQueryStrategyExectionInfo;
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* Request::release_reqquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  if (request_type_case() == kReqQueryStrategyExectionInfo) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerystrategyexectioninfo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& Request::_internal_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo ? *_impl_.request_type_.reqquerystrategyexectioninfo_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo&>(::lampyris::crypto::protocol::strategy::_ReqQueryStrategyExectionInfo_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& Request::reqquerystrategyexectioninfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  return _internal_reqquerystrategyexectioninfo();
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* Request::unsafe_arena_release_reqquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  if (request_type_case() == kReqQueryStrategyExectionInfo) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerystrategyexectioninfo_;
    _impl_.request_type_.reqquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqquerystrategyexectioninfo();
    _impl_.request_type_.reqquerystrategyexectioninfo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* Request::_internal_mutable_reqquerystrategyexectioninfo() {
  if (request_type_case() != kReqQueryStrategyExectionInfo) {
    clear_request_type();
    set_has_reqquerystrategyexectioninfo();
    _impl_.request_type_.reqquerystrategyexectioninfo_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo>(GetArena());
  }
  return _impl_.request_type_.reqquerystrategyexectioninfo_;
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* Request::mutable_reqquerystrategyexectioninfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* _msg = _internal_mutable_reqquerystrategyexectioninfo();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 16;
inline bool Request::has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline bool Request::_internal_has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline void Request::set_has_reqplaceorder() {
  _impl_._oneof_case_[0] = kReqPlaceOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::release_reqplaceorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqplaceorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::_internal_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder ? *_impl_.request_type_.reqplaceorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder&>(::lampyris::crypto::protocol::trading::_ReqPlaceOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::reqplaceorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _internal_reqplaceorder();
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::unsafe_arena_release_reqplaceorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqplaceorder_;
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::_internal_mutable_reqplaceorder() {
  if (request_type_case() != kReqPlaceOrder) {
    clear_request_type();
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqPlaceOrder>(GetArena());
  }
  return _impl_.request_type_.reqplaceorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::mutable_reqplaceorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* _msg = _internal_mutable_reqplaceorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 17;
inline bool Request::has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline bool Request::_internal_has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline void Request::set_has_reqmodifyorder() {
  _impl_._oneof_case_[0] = kReqModifyOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::release_reqmodifyorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifyorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::_internal_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder ? *_impl_.request_type_.reqmodifyorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder&>(::lampyris::crypto::protocol::trading::_ReqModifyOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::reqmodifyorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _internal_reqmodifyorder();
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::unsafe_arena_release_reqmodifyorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifyorder_;
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqModifyOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::_internal_mutable_reqmodifyorder() {
  if (request_type_case() != kReqModifyOrder) {
    clear_request_type();
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqModifyOrder>(GetArena());
  }
  return _impl_.request_type_.reqmodifyorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::mutable_reqmodifyorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* _msg = _internal_mutable_reqmodifyorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 18;
inline bool Request::has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline bool Request::_internal_has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline void Request::set_has_reqcancelorder() {
  _impl_._oneof_case_[0] = kReqCancelOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::release_reqcancelorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcancelorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::_internal_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder ? *_impl_.request_type_.reqcancelorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder&>(::lampyris::crypto::protocol::trading::_ReqCancelOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::reqcancelorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _internal_reqcancelorder();
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::unsafe_arena_release_reqcancelorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcancelorder_;
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCancelOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::_internal_mutable_reqcancelorder() {
  if (request_type_case() != kReqCancelOrder) {
    clear_request_type();
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqCancelOrder>(GetArena());
  }
  return _impl_.request_type_.reqcancelorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::mutable_reqcancelorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* _msg = _internal_mutable_reqcancelorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 19;
inline bool Request::has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline bool Request::_internal_has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline void Request::set_has_reqonekeycloseposition() {
  _impl_._oneof_case_[0] = kReqOneKeyClosePosition;
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqonekeycloseposition_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::_internal_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition ? *_impl_.request_type_.reqonekeycloseposition_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition&>(::lampyris::crypto::protocol::trading::_ReqOneKeyClosePosition_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::reqonekeycloseposition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _internal_reqonekeycloseposition();
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::unsafe_arena_release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqonekeycloseposition_;
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::_internal_mutable_reqonekeycloseposition() {
  if (request_type_case() != kReqOneKeyClosePosition) {
    clear_request_type();
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition>(GetArena());
  }
  return _impl_.request_type_.reqonekeycloseposition_;
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::mutable_reqonekeycloseposition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* _msg = _internal_mutable_reqonekeycloseposition();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 20;
inline bool Request::has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline bool Request::_internal_has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline void Request::set_has_reqqueryactiveorders() {
  _impl_._oneof_case_[0] = kReqQueryActiveOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryactiveorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::_internal_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders ? *_impl_.request_type_.reqqueryactiveorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryActiveOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::reqqueryactiveorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _internal_reqqueryactiveorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::unsafe_arena_release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryactiveorders_;
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::_internal_mutable_reqqueryactiveorders() {
  if (request_type_case() != kReqQueryActiveOrders) {
    clear_request_type();
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders>(GetArena());
  }
  return _impl_.request_type_.reqqueryactiveorders_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::mutable_reqqueryactiveorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* _msg = _internal_mutable_reqqueryactiveorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 21;
inline bool Request::has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline bool Request::_internal_has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline void Request::set_has_reqqueryhistoricalorders() {
  _impl_._oneof_case_[0] = kReqQueryHistoricalOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryhistoricalorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::_internal_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders ? *_impl_.request_type_.reqqueryhistoricalorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryHistoricalOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::reqqueryhistoricalorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _internal_reqqueryhistoricalorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::unsafe_arena_release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryhistoricalorders_;
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::_internal_mutable_reqqueryhistoricalorders() {
  if (request_type_case() != kReqQueryHistoricalOrders) {
    clear_request_type();
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders>(GetArena());
  }
  return _impl_.request_type_.reqqueryhistoricalorders_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::mutable_reqqueryhistoricalorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* _msg = _internal_mutable_reqqueryhistoricalorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 22;
inline bool Request::has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline bool Request::_internal_has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline void Request::set_has_reqquerypositions() {
  _impl_._oneof_case_[0] = kReqQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::release_reqquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerypositions_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::_internal_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions ? *_impl_.request_type_.reqquerypositions_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions&>(::lampyris::crypto::protocol::trading::_ReqQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::reqquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _internal_reqquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::unsafe_arena_release_reqquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerypositions_;
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::_internal_mutable_reqquerypositions() {
  if (request_type_case() != kReqQueryPositions) {
    clear_request_type();
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryPositions>(GetArena());
  }
  return _impl_.request_type_.reqquerypositions_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::mutable_reqquerypositions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* _msg = _internal_mutable_reqquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 23;
inline bool Request::has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline bool Request::_internal_has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline void Request::set_has_reqsetleverage() {
  _impl_._oneof_case_[0] = kReqSetLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::release_reqsetleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsetleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::_internal_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage ? *_impl_.request_type_.reqsetleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage&>(::lampyris::crypto::protocol::trading::_ReqSetLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::reqsetleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _internal_reqsetleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::unsafe_arena_release_reqsetleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsetleverage_;
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSetLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::_internal_mutable_reqsetleverage() {
  if (request_type_case() != kReqSetLeverage) {
    clear_request_type();
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqSetLeverage>(GetArena());
  }
  return _impl_.request_type_.reqsetleverage_;
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::mutable_reqsetleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* _msg = _internal_mutable_reqsetleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 24;
inline bool Request::has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline bool Request::_internal_has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline void Request::set_has_reqqueryleverage() {
  _impl_._oneof_case_[0] = kReqQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::release_reqqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::_internal_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage ? *_impl_.request_type_.reqqueryleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::reqqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _internal_reqqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::unsafe_arena_release_reqqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleverage_;
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::_internal_mutable_reqqueryleverage() {
  if (request_type_case() != kReqQueryLeverage) {
    clear_request_type();
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverage>(GetArena());
  }
  return _impl_.request_type_.reqqueryleverage_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::mutable_reqqueryleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* _msg = _internal_mutable_reqqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 25;
inline bool Request::has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline bool Request::_internal_has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline void Request::set_has_reqqueryleveragebracket() {
  _impl_._oneof_case_[0] = kReqQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleveragebracket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::_internal_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket ? *_impl_.request_type_.reqqueryleveragebracket_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::reqqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _internal_reqqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::unsafe_arena_release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleveragebracket_;
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::_internal_mutable_reqqueryleveragebracket() {
  if (request_type_case() != kReqQueryLeverageBracket) {
    clear_request_type();
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket>(GetArena());
  }
  return _impl_.request_type_.reqqueryleveragebracket_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::mutable_reqqueryleveragebracket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* _msg = _internal_mutable_reqqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .lampyris.crypto.protocol.account.AccountAssetInfoBean accountAssetInfoBean = 1;
inline bool Response::has_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean;
}
inline bool Response::_internal_has_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean;
}
inline void Response::set_has_accountassetinfobean() {
  _impl_._oneof_case_[0] = kAccountAssetInfoBean;
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* Response::release_accountassetinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  if (response_type_case() == kAccountAssetInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.accountassetinfobean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.accountassetinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& Response::_internal_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean ? *_impl_.response_type_.accountassetinfobean_ : reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean&>(::lampyris::crypto::protocol::account::_AccountAssetInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& Response::accountassetinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  return _internal_accountassetinfobean();
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* Response::unsafe_arena_release_accountassetinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  if (response_type_case() == kAccountAssetInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.accountassetinfobean_;
    _impl_.response_type_.accountassetinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_accountassetinfobean(::lampyris::crypto::protocol::account::AccountAssetInfoBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_accountassetinfobean();
    _impl_.response_type_.accountassetinfobean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* Response::_internal_mutable_accountassetinfobean() {
  if (response_type_case() != kAccountAssetInfoBean) {
    clear_response_type();
    set_has_accountassetinfobean();
    _impl_.response_type_.accountassetinfobean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AccountAssetInfoBean>(GetArena());
  }
  return _impl_.response_type_.accountassetinfobean_;
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* Response::mutable_accountassetinfobean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* _msg = _internal_mutable_accountassetinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.SubAccountInfoBean subAccountInfoBean = 2;
inline bool Response::has_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean;
}
inline bool Response::_internal_has_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean;
}
inline void Response::set_has_subaccountinfobean() {
  _impl_._oneof_case_[0] = kSubAccountInfoBean;
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* Response::release_subaccountinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  if (response_type_case() == kSubAccountInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.subaccountinfobean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.subaccountinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::SubAccountInfoBean& Response::_internal_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean ? *_impl_.response_type_.subaccountinfobean_ : reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean&>(::lampyris::crypto::protocol::account::_SubAccountInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::SubAccountInfoBean& Response::subaccountinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  return _internal_subaccountinfobean();
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* Response::unsafe_arena_release_subaccountinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  if (response_type_case() == kSubAccountInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.subaccountinfobean_;
    _impl_.response_type_.subaccountinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_subaccountinfobean(::lampyris::crypto::protocol::account::SubAccountInfoBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_subaccountinfobean();
    _impl_.response_type_.subaccountinfobean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* Response::_internal_mutable_subaccountinfobean() {
  if (response_type_case() != kSubAccountInfoBean) {
    clear_response_type();
    set_has_subaccountinfobean();
    _impl_.response_type_.subaccountinfobean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::SubAccountInfoBean>(GetArena());
  }
  return _impl_.response_type_.subaccountinfobean_;
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* Response::mutable_subaccountinfobean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* _msg = _internal_mutable_subaccountinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.ResQuerySubAcccountList resQuerySubAcccountList = 3;
inline bool Response::has_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList;
}
inline bool Response::_internal_has_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList;
}
inline void Response::set_has_resquerysubacccountlist() {
  _impl_._oneof_case_[0] = kResQuerySubAcccountList;
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* Response::release_resquerysubacccountlist() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  if (response_type_case() == kResQuerySubAcccountList) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerysubacccountlist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerysubacccountlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& Response::_internal_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList ? *_impl_.response_type_.resquerysubacccountlist_ : reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList&>(::lampyris::crypto::protocol::account::_ResQuerySubAcccountList_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& Response::resquerysubacccountlist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  return _internal_resquerysubacccountlist();
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* Response::unsafe_arena_release_resquerysubacccountlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  if (response_type_case() == kResQuerySubAcccountList) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerysubacccountlist_;
    _impl_.response_type_.resquerysubacccountlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerysubacccountlist(::lampyris::crypto::protocol::account::ResQuerySubAcccountList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerysubacccountlist();
    _impl_.response_type_.resquerysubacccountlist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* Response::_internal_mutable_resquerysubacccountlist() {
  if (response_type_case() != kResQuerySubAcccountList) {
    clear_response_type();
    set_has_resquerysubacccountlist();
    _impl_.response_type_.resquerysubacccountlist_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ResQuerySubAcccountList>(GetArena());
  }
  return _impl_.response_type_.resquerysubacccountlist_;
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* Response::mutable_resquerysubacccountlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* _msg = _internal_mutable_resquerysubacccountlist();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  return _msg;
}

// .lampyris.crypto.protocol.account.ResAccountSummaryUpdate resAccountSummaryUpdate = 4;
inline bool Response::has_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate;
}
inline bool Response::_internal_has_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate;
}
inline void Response::set_has_resaccountsummaryupdate() {
  _impl_._oneof_case_[0] = kResAccountSummaryUpdate;
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* Response::release_resaccountsummaryupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  if (response_type_case() == kResAccountSummaryUpdate) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resaccountsummaryupdate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& Response::_internal_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate ? *_impl_.response_type_.resaccountsummaryupdate_ : reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate&>(::lampyris::crypto::protocol::account::_ResAccountSummaryUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& Response::resaccountsummaryupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  return _internal_resaccountsummaryupdate();
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* Response::unsafe_arena_release_resaccountsummaryupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  if (response_type_case() == kResAccountSummaryUpdate) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resaccountsummaryupdate_;
    _impl_.response_type_.resaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resaccountsummaryupdate(::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resaccountsummaryupdate();
    _impl_.response_type_.resaccountsummaryupdate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* Response::_internal_mutable_resaccountsummaryupdate() {
  if (response_type_case() != kResAccountSummaryUpdate) {
    clear_response_type();
    set_has_resaccountsummaryupdate();
    _impl_.response_type_.resaccountsummaryupdate_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate>(GetArena());
  }
  return _impl_.response_type_.resaccountsummaryupdate_;
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* Response::mutable_resaccountsummaryupdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* _msg = _internal_mutable_resaccountsummaryupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.account.AssetTransferHistoryInfoDetailBean assetTransferHistoryInfoDetailBean = 5;
inline bool Response::has_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean;
}
inline bool Response::_internal_has_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean;
}
inline void Response::set_has_assettransferhistoryinfodetailbean() {
  _impl_._oneof_case_[0] = kAssetTransferHistoryInfoDetailBean;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* Response::release_assettransferhistoryinfodetailbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  if (response_type_case() == kAssetTransferHistoryInfoDetailBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.assettransferhistoryinfodetailbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& Response::_internal_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean ? *_impl_.response_type_.assettransferhistoryinfodetailbean_ : reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean&>(::lampyris::crypto::protocol::account::_AssetTransferHistoryInfoDetailBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& Response::assettransferhistoryinfodetailbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  return _internal_assettransferhistoryinfodetailbean();
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* Response::unsafe_arena_release_assettransferhistoryinfodetailbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  if (response_type_case() == kAssetTransferHistoryInfoDetailBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.assettransferhistoryinfodetailbean_;
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_assettransferhistoryinfodetailbean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_assettransferhistoryinfodetailbean();
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* Response::_internal_mutable_assettransferhistoryinfodetailbean() {
  if (response_type_case() != kAssetTransferHistoryInfoDetailBean) {
    clear_response_type();
    set_has_assettransferhistoryinfodetailbean();
    _impl_.response_type_.assettransferhistoryinfodetailbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean>(GetArena());
  }
  return _impl_.response_type_.assettransferhistoryinfodetailbean_;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* Response::mutable_assettransferhistoryinfodetailbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* _msg = _internal_mutable_assettransferhistoryinfodetailbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.AssetTransferHistoryInfoBean assetTransferHistoryInfoBean = 6;
inline bool Response::has_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean;
}
inline bool Response::_internal_has_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean;
}
inline void Response::set_has_assettransferhistoryinfobean() {
  _impl_._oneof_case_[0] = kAssetTransferHistoryInfoBean;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* Response::release_assettransferhistoryinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  if (response_type_case() == kAssetTransferHistoryInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.assettransferhistoryinfobean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.assettransferhistoryinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& Response::_internal_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean ? *_impl_.response_type_.assettransferhistoryinfobean_ : reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean&>(::lampyris::crypto::protocol::account::_AssetTransferHistoryInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& Response::assettransferhistoryinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  return _internal_assettransferhistoryinfobean();
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* Response::unsafe_arena_release_assettransferhistoryinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  if (response_type_case() == kAssetTransferHistoryInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.assettransferhistoryinfobean_;
    _impl_.response_type_.assettransferhistoryinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_assettransferhistoryinfobean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_assettransferhistoryinfobean();
    _impl_.response_type_.assettransferhistoryinfobean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* Response::_internal_mutable_assettransferhistoryinfobean() {
  if (response_type_case() != kAssetTransferHistoryInfoBean) {
    clear_response_type();
    set_has_assettransferhistoryinfobean();
    _impl_.response_type_.assettransferhistoryinfobean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean>(GetArena());
  }
  return _impl_.response_type_.assettransferhistoryinfobean_;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* Response::mutable_assettransferhistoryinfobean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* _msg = _internal_mutable_assettransferhistoryinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResLogin resLogin = 7;
inline bool Response::has_reslogin() const {
  return response_type_case() == kResLogin;
}
inline bool Response::_internal_has_reslogin() const {
  return response_type_case() == kResLogin;
}
inline void Response::set_has_reslogin() {
  _impl_._oneof_case_[0] = kResLogin;
}
inline ::lampyris::crypto::protocol::app::ResLogin* Response::release_reslogin() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resLogin)
  if (response_type_case() == kResLogin) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.reslogin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.reslogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResLogin& Response::_internal_reslogin() const {
  return response_type_case() == kResLogin ? *_impl_.response_type_.reslogin_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin&>(::lampyris::crypto::protocol::app::_ResLogin_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResLogin& Response::reslogin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resLogin)
  return _internal_reslogin();
}
inline ::lampyris::crypto::protocol::app::ResLogin* Response::unsafe_arena_release_reslogin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resLogin)
  if (response_type_case() == kResLogin) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.reslogin_;
    _impl_.response_type_.reslogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_reslogin(::lampyris::crypto::protocol::app::ResLogin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_reslogin();
    _impl_.response_type_.reslogin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resLogin)
}
inline ::lampyris::crypto::protocol::app::ResLogin* Response::_internal_mutable_reslogin() {
  if (response_type_case() != kResLogin) {
    clear_response_type();
    set_has_reslogin();
    _impl_.response_type_.reslogin_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResLogin>(GetArena());
  }
  return _impl_.response_type_.reslogin_;
}
inline ::lampyris::crypto::protocol::app::ResLogin* Response::mutable_reslogin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResLogin* _msg = _internal_mutable_reslogin();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resLogin)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 8;
inline bool Response::has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline bool Response::_internal_has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline void Response::set_has_resheartbeat() {
  _impl_._oneof_case_[0] = kResHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::release_resheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resheartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::_internal_resheartbeat() const {
  return response_type_case() == kResHeartBeat ? *_impl_.response_type_.resheartbeat_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat&>(::lampyris::crypto::protocol::app::_ResHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::resheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _internal_resheartbeat();
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::unsafe_arena_release_resheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resheartbeat_;
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::_internal_mutable_resheartbeat() {
  if (response_type_case() != kResHeartBeat) {
    clear_response_type();
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResHeartBeat>(GetArena());
  }
  return _impl_.response_type_.resheartbeat_;
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::mutable_resheartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResHeartBeat* _msg = _internal_mutable_resheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResNotice resNotice = 9;
inline bool Response::has_resnotice() const {
  return response_type_case() == kResNotice;
}
inline bool Response::_internal_has_resnotice() const {
  return response_type_case() == kResNotice;
}
inline void Response::set_has_resnotice() {
  _impl_._oneof_case_[0] = kResNotice;
}
inline ::lampyris::crypto::protocol::app::ResNotice* Response::release_resnotice() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resNotice)
  if (response_type_case() == kResNotice) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resnotice_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resnotice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResNotice& Response::_internal_resnotice() const {
  return response_type_case() == kResNotice ? *_impl_.response_type_.resnotice_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice&>(::lampyris::crypto::protocol::app::_ResNotice_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResNotice& Response::resnotice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resNotice)
  return _internal_resnotice();
}
inline ::lampyris::crypto::protocol::app::ResNotice* Response::unsafe_arena_release_resnotice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resNotice)
  if (response_type_case() == kResNotice) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resnotice_;
    _impl_.response_type_.resnotice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resnotice(::lampyris::crypto::protocol::app::ResNotice* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resnotice();
    _impl_.response_type_.resnotice_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resNotice)
}
inline ::lampyris::crypto::protocol::app::ResNotice* Response::_internal_mutable_resnotice() {
  if (response_type_case() != kResNotice) {
    clear_response_type();
    set_has_resnotice();
    _impl_.response_type_.resnotice_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResNotice>(GetArena());
  }
  return _impl_.response_type_.resnotice_;
}
inline ::lampyris::crypto::protocol::app::ResNotice* Response::mutable_resnotice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResNotice* _msg = _internal_mutable_resnotice();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resNotice)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTickerDataBean symbolTickerDataBean = 10;
inline bool Response::has_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean;
}
inline bool Response::_internal_has_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean;
}
inline void Response::set_has_symboltickerdatabean() {
  _impl_._oneof_case_[0] = kSymbolTickerDataBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* Response::release_symboltickerdatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  if (response_type_case() == kSymbolTickerDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltickerdatabean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltickerdatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& Response::_internal_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean ? *_impl_.response_type_.symboltickerdatabean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean&>(::lampyris::crypto::protocol::quote::_SymbolTickerDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& Response::symboltickerdatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  return _internal_symboltickerdatabean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* Response::unsafe_arena_release_symboltickerdatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  if (response_type_case() == kSymbolTickerDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltickerdatabean_;
    _impl_.response_type_.symboltickerdatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltickerdatabean(::lampyris::crypto::protocol::quote::SymbolTickerDataBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltickerdatabean();
    _impl_.response_type_.symboltickerdatabean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* Response::_internal_mutable_symboltickerdatabean() {
  if (response_type_case() != kSymbolTickerDataBean) {
    clear_response_type();
    set_has_symboltickerdatabean();
    _impl_.response_type_.symboltickerdatabean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTickerDataBean>(GetArena());
  }
  return _impl_.response_type_.symboltickerdatabean_;
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* Response::mutable_symboltickerdatabean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* _msg = _internal_mutable_symboltickerdatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 11;
inline bool Response::has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline bool Response::_internal_has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline void Response::set_has_ressubscribetickerdata() {
  _impl_._oneof_case_[0] = kResSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.ressubscribetickerdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::_internal_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData ? *_impl_.response_type_.ressubscribetickerdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ResSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::ressubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _internal_ressubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::unsafe_arena_release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.ressubscribetickerdata_;
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::_internal_mutable_ressubscribetickerdata() {
  if (response_type_case() != kResSubscribeTickerData) {
    clear_response_type();
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSubscribeTickerData>(GetArena());
  }
  return _impl_.response_type_.ressubscribetickerdata_;
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::mutable_ressubscribetickerdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* _msg = _internal_mutable_ressubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTradeDataBean symbolTradeDataBean = 12;
inline bool Response::has_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean;
}
inline bool Response::_internal_has_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean;
}
inline void Response::set_has_symboltradedatabean() {
  _impl_._oneof_case_[0] = kSymbolTradeDataBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* Response::release_symboltradedatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  if (response_type_case() == kSymbolTradeDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltradedatabean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& Response::_internal_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean ? *_impl_.response_type_.symboltradedatabean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean&>(::lampyris::crypto::protocol::quote::_SymbolTradeDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& Response::symboltradedatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  return _internal_symboltradedatabean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* Response::unsafe_arena_release_symboltradedatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  if (response_type_case() == kSymbolTradeDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltradedatabean_;
    _impl_.response_type_.symboltradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltradedatabean(::lampyris::crypto::protocol::quote::SymbolTradeDataBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltradedatabean();
    _impl_.response_type_.symboltradedatabean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* Response::_internal_mutable_symboltradedatabean() {
  if (response_type_case() != kSymbolTradeDataBean) {
    clear_response_type();
    set_has_symboltradedatabean();
    _impl_.response_type_.symboltradedatabean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTradeDataBean>(GetArena());
  }
  return _impl_.response_type_.symboltradedatabean_;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* Response::mutable_symboltradedatabean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* _msg = _internal_mutable_symboltradedatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.TradeDataBean tradeDataBean = 13;
inline bool Response::has_tradedatabean() const {
  return response_type_case() == kTradeDataBean;
}
inline bool Response::_internal_has_tradedatabean() const {
  return response_type_case() == kTradeDataBean;
}
inline void Response::set_has_tradedatabean() {
  _impl_._oneof_case_[0] = kTradeDataBean;
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* Response::release_tradedatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.tradeDataBean)
  if (response_type_case() == kTradeDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.tradedatabean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.tradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::TradeDataBean& Response::_internal_tradedatabean() const {
  return response_type_case() == kTradeDataBean ? *_impl_.response_type_.tradedatabean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean&>(::lampyris::crypto::protocol::quote::_TradeDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::TradeDataBean& Response::tradedatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.tradeDataBean)
  return _internal_tradedatabean();
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* Response::unsafe_arena_release_tradedatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.tradeDataBean)
  if (response_type_case() == kTradeDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.tradedatabean_;
    _impl_.response_type_.tradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tradedatabean(::lampyris::crypto::protocol::quote::TradeDataBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_tradedatabean();
    _impl_.response_type_.tradedatabean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.tradeDataBean)
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* Response::_internal_mutable_tradedatabean() {
  if (response_type_case() != kTradeDataBean) {
    clear_response_type();
    set_has_tradedatabean();
    _impl_.response_type_.tradedatabean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::TradeDataBean>(GetArena());
  }
  return _impl_.response_type_.tradedatabean_;
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* Response::mutable_tradedatabean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::TradeDataBean* _msg = _internal_mutable_tradedatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.tradeDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 14;
inline bool Response::has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline bool Response::_internal_has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline void Response::set_has_rescandlestickquery() {
  _impl_._oneof_case_[0] = kResCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::release_rescandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.rescandlestickquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::_internal_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery ? *_impl_.response_type_.rescandlestickquery_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ResCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::rescandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _internal_rescandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::unsafe_arena_release_rescandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.rescandlestickquery_;
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::_internal_mutable_rescandlestickquery() {
  if (response_type_case() != kResCandlestickQuery) {
    clear_response_type();
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResCandlestickQuery>(GetArena());
  }
  return _impl_.response_type_.rescandlestickquery_;
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::mutable_rescandlestickquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* _msg = _internal_mutable_rescandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.CandlestickUpdateBean candlestickUpdateBean = 15;
inline bool Response::has_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean;
}
inline bool Response::_internal_has_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean;
}
inline void Response::set_has_candlestickupdatebean() {
  _impl_._oneof_case_[0] = kCandlestickUpdateBean;
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* Response::release_candlestickupdatebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  if (response_type_case() == kCandlestickUpdateBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.candlestickupdatebean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.candlestickupdatebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& Response::_internal_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean ? *_impl_.response_type_.candlestickupdatebean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean&>(::lampyris::crypto::protocol::quote::_CandlestickUpdateBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& Response::candlestickupdatebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  return _internal_candlestickupdatebean();
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* Response::unsafe_arena_release_candlestickupdatebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  if (response_type_case() == kCandlestickUpdateBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.candlestickupdatebean_;
    _impl_.response_type_.candlestickupdatebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_candlestickupdatebean(::lampyris::crypto::protocol::quote::CandlestickUpdateBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_candlestickupdatebean();
    _impl_.response_type_.candlestickupdatebean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* Response::_internal_mutable_candlestickupdatebean() {
  if (response_type_case() != kCandlestickUpdateBean) {
    clear_response_type();
    set_has_candlestickupdatebean();
    _impl_.response_type_.candlestickupdatebean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::CandlestickUpdateBean>(GetArena());
  }
  return _impl_.response_type_.candlestickupdatebean_;
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* Response::mutable_candlestickupdatebean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* _msg = _internal_mutable_candlestickupdatebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.CandlestickBean candlestickBean = 16;
inline bool Response::has_candlestickbean() const {
  return response_type_case() == kCandlestickBean;
}
inline bool Response::_internal_has_candlestickbean() const {
  return response_type_case() == kCandlestickBean;
}
inline void Response::set_has_candlestickbean() {
  _impl_._oneof_case_[0] = kCandlestickBean;
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* Response::release_candlestickbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.candlestickBean)
  if (response_type_case() == kCandlestickBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.candlestickbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.candlestickbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::CandlestickBean& Response::_internal_candlestickbean() const {
  return response_type_case() == kCandlestickBean ? *_impl_.response_type_.candlestickbean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean&>(::lampyris::crypto::protocol::quote::_CandlestickBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::CandlestickBean& Response::candlestickbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.candlestickBean)
  return _internal_candlestickbean();
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* Response::unsafe_arena_release_candlestickbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.candlestickBean)
  if (response_type_case() == kCandlestickBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.candlestickbean_;
    _impl_.response_type_.candlestickbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_candlestickbean(::lampyris::crypto::protocol::quote::CandlestickBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_candlestickbean();
    _impl_.response_type_.candlestickbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.candlestickBean)
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* Response::_internal_mutable_candlestickbean() {
  if (response_type_case() != kCandlestickBean) {
    clear_response_type();
    set_has_candlestickbean();
    _impl_.response_type_.candlestickbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::CandlestickBean>(GetArena());
  }
  return _impl_.response_type_.candlestickbean_;
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* Response::mutable_candlestickbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::CandlestickBean* _msg = _internal_mutable_candlestickbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.candlestickBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 17;
inline bool Response::has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline bool Response::_internal_has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline void Response::set_has_restraderule() {
  _impl_._oneof_case_[0] = kResTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::release_restraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.restraderule_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::_internal_restraderule() const {
  return response_type_case() == kResTradeRule ? *_impl_.response_type_.restraderule_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule&>(::lampyris::crypto::protocol::quote::_ResTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::restraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _internal_restraderule();
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::unsafe_arena_release_restraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.restraderule_;
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_restraderule();
    _impl_.response_type_.restraderule_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::_internal_mutable_restraderule() {
  if (response_type_case() != kResTradeRule) {
    clear_response_type();
    set_has_restraderule();
    _impl_.response_type_.restraderule_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResTradeRule>(GetArena());
  }
  return _impl_.response_type_.restraderule_;
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::mutable_restraderule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResTradeRule* _msg = _internal_mutable_restraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTradeRuleBean symbolTradeRuleBean = 18;
inline bool Response::has_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean;
}
inline bool Response::_internal_has_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean;
}
inline void Response::set_has_symboltraderulebean() {
  _impl_._oneof_case_[0] = kSymbolTradeRuleBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* Response::release_symboltraderulebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  if (response_type_case() == kSymbolTradeRuleBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltraderulebean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltraderulebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& Response::_internal_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean ? *_impl_.response_type_.symboltraderulebean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean&>(::lampyris::crypto::protocol::quote::_SymbolTradeRuleBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& Response::symboltraderulebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  return _internal_symboltraderulebean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* Response::unsafe_arena_release_symboltraderulebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  if (response_type_case() == kSymbolTradeRuleBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symboltraderulebean_;
    _impl_.response_type_.symboltraderulebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltraderulebean(::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltraderulebean();
    _impl_.response_type_.symboltraderulebean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* Response::_internal_mutable_symboltraderulebean() {
  if (response_type_case() != kSymbolTradeRuleBean) {
    clear_response_type();
    set_has_symboltraderulebean();
    _impl_.response_type_.symboltraderulebean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean>(GetArena());
  }
  return _impl_.response_type_.symboltraderulebean_;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* Response::mutable_symboltraderulebean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* _msg = _internal_mutable_symboltraderulebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketMonitorNoticeListBean marketMonitorNoticeListBean = 19;
inline bool Response::has_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean;
}
inline bool Response::_internal_has_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean;
}
inline void Response::set_has_marketmonitornoticelistbean() {
  _impl_._oneof_case_[0] = kMarketMonitorNoticeListBean;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* Response::release_marketmonitornoticelistbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  if (response_type_case() == kMarketMonitorNoticeListBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketmonitornoticelistbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketmonitornoticelistbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& Response::_internal_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean ? *_impl_.response_type_.marketmonitornoticelistbean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean&>(::lampyris::crypto::protocol::quote::_MarketMonitorNoticeListBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& Response::marketmonitornoticelistbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  return _internal_marketmonitornoticelistbean();
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* Response::unsafe_arena_release_marketmonitornoticelistbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  if (response_type_case() == kMarketMonitorNoticeListBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketmonitornoticelistbean_;
    _impl_.response_type_.marketmonitornoticelistbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketmonitornoticelistbean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketmonitornoticelistbean();
    _impl_.response_type_.marketmonitornoticelistbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* Response::_internal_mutable_marketmonitornoticelistbean() {
  if (response_type_case() != kMarketMonitorNoticeListBean) {
    clear_response_type();
    set_has_marketmonitornoticelistbean();
    _impl_.response_type_.marketmonitornoticelistbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean>(GetArena());
  }
  return _impl_.response_type_.marketmonitornoticelistbean_;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* Response::mutable_marketmonitornoticelistbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* _msg = _internal_mutable_marketmonitornoticelistbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketMonitorNoticeBean marketMonitorNoticeBean = 20;
inline bool Response::has_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean;
}
inline bool Response::_internal_has_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean;
}
inline void Response::set_has_marketmonitornoticebean() {
  _impl_._oneof_case_[0] = kMarketMonitorNoticeBean;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* Response::release_marketmonitornoticebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  if (response_type_case() == kMarketMonitorNoticeBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketmonitornoticebean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketmonitornoticebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& Response::_internal_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean ? *_impl_.response_type_.marketmonitornoticebean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean&>(::lampyris::crypto::protocol::quote::_MarketMonitorNoticeBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& Response::marketmonitornoticebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  return _internal_marketmonitornoticebean();
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* Response::unsafe_arena_release_marketmonitornoticebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  if (response_type_case() == kMarketMonitorNoticeBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketmonitornoticebean_;
    _impl_.response_type_.marketmonitornoticebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketmonitornoticebean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketmonitornoticebean();
    _impl_.response_type_.marketmonitornoticebean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* Response::_internal_mutable_marketmonitornoticebean() {
  if (response_type_case() != kMarketMonitorNoticeBean) {
    clear_response_type();
    set_has_marketmonitornoticebean();
    _impl_.response_type_.marketmonitornoticebean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean>(GetArena());
  }
  return _impl_.response_type_.marketmonitornoticebean_;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* Response::mutable_marketmonitornoticebean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* _msg = _internal_mutable_marketmonitornoticebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SelfSelectedSymbolInfoBean selfSelectedSymbolInfoBean = 21;
inline bool Response::has_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean;
}
inline bool Response::_internal_has_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean;
}
inline void Response::set_has_selfselectedsymbolinfobean() {
  _impl_._oneof_case_[0] = kSelfSelectedSymbolInfoBean;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* Response::release_selfselectedsymbolinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  if (response_type_case() == kSelfSelectedSymbolInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.selfselectedsymbolinfobean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.selfselectedsymbolinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& Response::_internal_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean ? *_impl_.response_type_.selfselectedsymbolinfobean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean&>(::lampyris::crypto::protocol::quote::_SelfSelectedSymbolInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& Response::selfselectedsymbolinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  return _internal_selfselectedsymbolinfobean();
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* Response::unsafe_arena_release_selfselectedsymbolinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  if (response_type_case() == kSelfSelectedSymbolInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.selfselectedsymbolinfobean_;
    _impl_.response_type_.selfselectedsymbolinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_selfselectedsymbolinfobean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_selfselectedsymbolinfobean();
    _impl_.response_type_.selfselectedsymbolinfobean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* Response::_internal_mutable_selfselectedsymbolinfobean() {
  if (response_type_case() != kSelfSelectedSymbolInfoBean) {
    clear_response_type();
    set_has_selfselectedsymbolinfobean();
    _impl_.response_type_.selfselectedsymbolinfobean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean>(GetArena());
  }
  return _impl_.response_type_.selfselectedsymbolinfobean_;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* Response::mutable_selfselectedsymbolinfobean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* _msg = _internal_mutable_selfselectedsymbolinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SelfSelectedSymbolGroupBean selfSelectedSymbolGroupBean = 22;
inline bool Response::has_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean;
}
inline bool Response::_internal_has_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean;
}
inline void Response::set_has_selfselectedsymbolgroupbean() {
  _impl_._oneof_case_[0] = kSelfSelectedSymbolGroupBean;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* Response::release_selfselectedsymbolgroupbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  if (response_type_case() == kSelfSelectedSymbolGroupBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.selfselectedsymbolgroupbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.selfselectedsymbolgroupbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& Response::_internal_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean ? *_impl_.response_type_.selfselectedsymbolgroupbean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean&>(::lampyris::crypto::protocol::quote::_SelfSelectedSymbolGroupBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& Response::selfselectedsymbolgroupbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  return _internal_selfselectedsymbolgroupbean();
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* Response::unsafe_arena_release_selfselectedsymbolgroupbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  if (response_type_case() == kSelfSelectedSymbolGroupBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.selfselectedsymbolgroupbean_;
    _impl_.response_type_.selfselectedsymbolgroupbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_selfselectedsymbolgroupbean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_selfselectedsymbolgroupbean();
    _impl_.response_type_.selfselectedsymbolgroupbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* Response::_internal_mutable_selfselectedsymbolgroupbean() {
  if (response_type_case() != kSelfSelectedSymbolGroupBean) {
    clear_response_type();
    set_has_selfselectedsymbolgroupbean();
    _impl_.response_type_.selfselectedsymbolgroupbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean>(GetArena());
  }
  return _impl_.response_type_.selfselectedsymbolgroupbean_;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* Response::mutable_selfselectedsymbolgroupbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* _msg = _internal_mutable_selfselectedsymbolgroupbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 23;
inline bool Response::has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline bool Response::_internal_has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline void Response::set_has_resselfselectedsymbol() {
  _impl_._oneof_case_[0] = kResSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resselfselectedsymbol_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::_internal_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol ? *_impl_.response_type_.resselfselectedsymbol_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ResSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::resselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _internal_resselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::unsafe_arena_release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resselfselectedsymbol_;
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::_internal_mutable_resselfselectedsymbol() {
  if (response_type_case() != kResSelfSelectedSymbol) {
    clear_response_type();
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol>(GetArena());
  }
  return _impl_.response_type_.resselfselectedsymbol_;
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::mutable_resselfselectedsymbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* _msg = _internal_mutable_resselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketPreviewIntervalDataBean marketPreviewIntervalDataBean = 24;
inline bool Response::has_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean;
}
inline bool Response::_internal_has_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean;
}
inline void Response::set_has_marketpreviewintervaldatabean() {
  _impl_._oneof_case_[0] = kMarketPreviewIntervalDataBean;
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* Response::release_marketpreviewintervaldatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  if (response_type_case() == kMarketPreviewIntervalDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketpreviewintervaldatabean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketpreviewintervaldatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& Response::_internal_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean ? *_impl_.response_type_.marketpreviewintervaldatabean_ : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean&>(::lampyris::crypto::protocol::quote::_MarketPreviewIntervalDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& Response::marketpreviewintervaldatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  return _internal_marketpreviewintervaldatabean();
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* Response::unsafe_arena_release_marketpreviewintervaldatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  if (response_type_case() == kMarketPreviewIntervalDataBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.marketpreviewintervaldatabean_;
    _impl_.response_type_.marketpreviewintervaldatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketpreviewintervaldatabean(::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketpreviewintervaldatabean();
    _impl_.response_type_.marketpreviewintervaldatabean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* Response::_internal_mutable_marketpreviewintervaldatabean() {
  if (response_type_case() != kMarketPreviewIntervalDataBean) {
    clear_response_type();
    set_has_marketpreviewintervaldatabean();
    _impl_.response_type_.marketpreviewintervaldatabean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean>(GetArena());
  }
  return _impl_.response_type_.marketpreviewintervaldatabean_;
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* Response::mutable_marketpreviewintervaldatabean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* _msg = _internal_mutable_marketpreviewintervaldatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 25;
inline bool Response::has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline bool Response::_internal_has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline void Response::set_has_resmarketpreviewdata() {
  _impl_._oneof_case_[0] = kResMarketPreviewData;
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmarketpreviewdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::_internal_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData ? *_impl_.response_type_.resmarketpreviewdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData&>(::lampyris::crypto::protocol::quote::_ResMarketPreviewData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::resmarketpreviewdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _internal_resmarketpreviewdata();
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::unsafe_arena_release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmarketpreviewdata_;
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::_internal_mutable_resmarketpreviewdata() {
  if (response_type_case() != kResMarketPreviewData) {
    clear_response_type();
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResMarketPreviewData>(GetArena());
  }
  return _impl_.response_type_.resmarketpreviewdata_;
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::mutable_resmarketpreviewdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* _msg = _internal_mutable_resmarketpreviewdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StreategyConfigBean streategyConfigBean = 26;
inline bool Response::has_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean;
}
inline bool Response::_internal_has_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean;
}
inline void Response::set_has_streategyconfigbean() {
  _impl_._oneof_case_[0] = kStreategyConfigBean;
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* Response::release_streategyconfigbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  if (response_type_case() == kStreategyConfigBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.streategyconfigbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.streategyconfigbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& Response::_internal_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean ? *_impl_.response_type_.streategyconfigbean_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean&>(::lampyris::crypto::protocol::strategy::_StreategyConfigBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& Response::streategyconfigbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  return _internal_streategyconfigbean();
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* Response::unsafe_arena_release_streategyconfigbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  if (response_type_case() == kStreategyConfigBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.streategyconfigbean_;
    _impl_.response_type_.streategyconfigbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_streategyconfigbean(::lampyris::crypto::protocol::strategy::StreategyConfigBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_streategyconfigbean();
    _impl_.response_type_.streategyconfigbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.streategyConfigBean)
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* Response::_internal_mutable_streategyconfigbean() {
  if (response_type_case() != kStreategyConfigBean) {
    clear_response_type();
    set_has_streategyconfigbean();
    _impl_.response_type_.streategyconfigbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StreategyConfigBean>(GetArena());
  }
  return _impl_.response_type_.streategyconfigbean_;
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* Response::mutable_streategyconfigbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* _msg = _internal_mutable_streategyconfigbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StreategyFieldBean streategyFieldBean = 27;
inline bool Response::has_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean;
}
inline bool Response::_internal_has_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean;
}
inline void Response::set_has_streategyfieldbean() {
  _impl_._oneof_case_[0] = kStreategyFieldBean;
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* Response::release_streategyfieldbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  if (response_type_case() == kStreategyFieldBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.streategyfieldbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.streategyfieldbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& Response::_internal_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean ? *_impl_.response_type_.streategyfieldbean_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean&>(::lampyris::crypto::protocol::strategy::_StreategyFieldBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& Response::streategyfieldbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  return _internal_streategyfieldbean();
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* Response::unsafe_arena_release_streategyfieldbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  if (response_type_case() == kStreategyFieldBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.streategyfieldbean_;
    _impl_.response_type_.streategyfieldbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_streategyfieldbean(::lampyris::crypto::protocol::strategy::StreategyFieldBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_streategyfieldbean();
    _impl_.response_type_.streategyfieldbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.streategyFieldBean)
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* Response::_internal_mutable_streategyfieldbean() {
  if (response_type_case() != kStreategyFieldBean) {
    clear_response_type();
    set_has_streategyfieldbean();
    _impl_.response_type_.streategyfieldbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StreategyFieldBean>(GetArena());
  }
  return _impl_.response_type_.streategyfieldbean_;
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* Response::mutable_streategyfieldbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* _msg = _internal_mutable_streategyfieldbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResModifyStreategySetting resModifyStreategySetting = 28;
inline bool Response::has_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting;
}
inline bool Response::_internal_has_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting;
}
inline void Response::set_has_resmodifystreategysetting() {
  _impl_._oneof_case_[0] = kResModifyStreategySetting;
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* Response::release_resmodifystreategysetting() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  if (response_type_case() == kResModifyStreategySetting) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmodifystreategysetting_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& Response::_internal_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting ? *_impl_.response_type_.resmodifystreategysetting_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting&>(::lampyris::crypto::protocol::strategy::_ResModifyStreategySetting_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& Response::resmodifystreategysetting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  return _internal_resmodifystreategysetting();
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* Response::unsafe_arena_release_resmodifystreategysetting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  if (response_type_case() == kResModifyStreategySetting) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmodifystreategysetting_;
    _impl_.response_type_.resmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resmodifystreategysetting(::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resmodifystreategysetting();
    _impl_.response_type_.resmodifystreategysetting_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* Response::_internal_mutable_resmodifystreategysetting() {
  if (response_type_case() != kResModifyStreategySetting) {
    clear_response_type();
    set_has_resmodifystreategysetting();
    _impl_.response_type_.resmodifystreategysetting_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting>(GetArena());
  }
  return _impl_.response_type_.resmodifystreategysetting_;
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* Response::mutable_resmodifystreategysetting() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* _msg = _internal_mutable_resmodifystreategysetting();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStreategySettings resStreategySettings = 29;
inline bool Response::has_resstreategysettings() const {
  return response_type_case() == kResStreategySettings;
}
inline bool Response::_internal_has_resstreategysettings() const {
  return response_type_case() == kResStreategySettings;
}
inline void Response::set_has_resstreategysettings() {
  _impl_._oneof_case_[0] = kResStreategySettings;
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* Response::release_resstreategysettings() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStreategySettings)
  if (response_type_case() == kResStreategySettings) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstreategysettings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstreategysettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStreategySettings& Response::_internal_resstreategysettings() const {
  return response_type_case() == kResStreategySettings ? *_impl_.response_type_.resstreategysettings_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings&>(::lampyris::crypto::protocol::strategy::_ResStreategySettings_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStreategySettings& Response::resstreategysettings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStreategySettings)
  return _internal_resstreategysettings();
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* Response::unsafe_arena_release_resstreategysettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStreategySettings)
  if (response_type_case() == kResStreategySettings) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstreategysettings_;
    _impl_.response_type_.resstreategysettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstreategysettings(::lampyris::crypto::protocol::strategy::ResStreategySettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstreategysettings();
    _impl_.response_type_.resstreategysettings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStreategySettings)
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* Response::_internal_mutable_resstreategysettings() {
  if (response_type_case() != kResStreategySettings) {
    clear_response_type();
    set_has_resstreategysettings();
    _impl_.response_type_.resstreategysettings_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStreategySettings>(GetArena());
  }
  return _impl_.response_type_.resstreategysettings_;
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* Response::mutable_resstreategysettings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* _msg = _internal_mutable_resstreategysettings();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStreategySettings)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StrategyExectionInfoBean strategyExectionInfoBean = 30;
inline bool Response::has_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean;
}
inline bool Response::_internal_has_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean;
}
inline void Response::set_has_strategyexectioninfobean() {
  _impl_._oneof_case_[0] = kStrategyExectionInfoBean;
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* Response::release_strategyexectioninfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  if (response_type_case() == kStrategyExectionInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.strategyexectioninfobean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.strategyexectioninfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& Response::_internal_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean ? *_impl_.response_type_.strategyexectioninfobean_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean&>(::lampyris::crypto::protocol::strategy::_StrategyExectionInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& Response::strategyexectioninfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  return _internal_strategyexectioninfobean();
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* Response::unsafe_arena_release_strategyexectioninfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  if (response_type_case() == kStrategyExectionInfoBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.strategyexectioninfobean_;
    _impl_.response_type_.strategyexectioninfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_strategyexectioninfobean(::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_strategyexectioninfobean();
    _impl_.response_type_.strategyexectioninfobean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* Response::_internal_mutable_strategyexectioninfobean() {
  if (response_type_case() != kStrategyExectionInfoBean) {
    clear_response_type();
    set_has_strategyexectioninfobean();
    _impl_.response_type_.strategyexectioninfobean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean>(GetArena());
  }
  return _impl_.response_type_.strategyexectioninfobean_;
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* Response::mutable_strategyexectioninfobean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* _msg = _internal_mutable_strategyexectioninfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResQueryStrategyExectionInfo resQueryStrategyExectionInfo = 31;
inline bool Response::has_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo;
}
inline bool Response::_internal_has_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo;
}
inline void Response::set_has_resquerystrategyexectioninfo() {
  _impl_._oneof_case_[0] = kResQueryStrategyExectionInfo;
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* Response::release_resquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  if (response_type_case() == kResQueryStrategyExectionInfo) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerystrategyexectioninfo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& Response::_internal_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo ? *_impl_.response_type_.resquerystrategyexectioninfo_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo&>(::lampyris::crypto::protocol::strategy::_ResQueryStrategyExectionInfo_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& Response::resquerystrategyexectioninfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  return _internal_resquerystrategyexectioninfo();
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* Response::unsafe_arena_release_resquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  if (response_type_case() == kResQueryStrategyExectionInfo) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerystrategyexectioninfo_;
    _impl_.response_type_.resquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerystrategyexectioninfo();
    _impl_.response_type_.resquerystrategyexectioninfo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* Response::_internal_mutable_resquerystrategyexectioninfo() {
  if (response_type_case() != kResQueryStrategyExectionInfo) {
    clear_response_type();
    set_has_resquerystrategyexectioninfo();
    _impl_.response_type_.resquerystrategyexectioninfo_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo>(GetArena());
  }
  return _impl_.response_type_.resquerystrategyexectioninfo_;
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* Response::mutable_resquerystrategyexectioninfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* _msg = _internal_mutable_resquerystrategyexectioninfo();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ConditionTriggerBean conditionTriggerBean = 32;
inline bool Response::has_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean;
}
inline bool Response::_internal_has_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean;
}
inline void Response::set_has_conditiontriggerbean() {
  _impl_._oneof_case_[0] = kConditionTriggerBean;
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* Response::release_conditiontriggerbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  if (response_type_case() == kConditionTriggerBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.conditiontriggerbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.conditiontriggerbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& Response::_internal_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean ? *_impl_.response_type_.conditiontriggerbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean&>(::lampyris::crypto::protocol::trading::_ConditionTriggerBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& Response::conditiontriggerbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  return _internal_conditiontriggerbean();
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* Response::unsafe_arena_release_conditiontriggerbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  if (response_type_case() == kConditionTriggerBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.conditiontriggerbean_;
    _impl_.response_type_.conditiontriggerbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_conditiontriggerbean(::lampyris::crypto::protocol::trading::ConditionTriggerBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_conditiontriggerbean();
    _impl_.response_type_.conditiontriggerbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* Response::_internal_mutable_conditiontriggerbean() {
  if (response_type_case() != kConditionTriggerBean) {
    clear_response_type();
    set_has_conditiontriggerbean();
    _impl_.response_type_.conditiontriggerbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ConditionTriggerBean>(GetArena());
  }
  return _impl_.response_type_.conditiontriggerbean_;
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* Response::mutable_conditiontriggerbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* _msg = _internal_mutable_conditiontriggerbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.OrderBean orderBean = 33;
inline bool Response::has_orderbean() const {
  return response_type_case() == kOrderBean;
}
inline bool Response::_internal_has_orderbean() const {
  return response_type_case() == kOrderBean;
}
inline void Response::set_has_orderbean() {
  _impl_._oneof_case_[0] = kOrderBean;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* Response::release_orderbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.orderBean)
  if (response_type_case() == kOrderBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.orderbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.orderbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& Response::_internal_orderbean() const {
  return response_type_case() == kOrderBean ? *_impl_.response_type_.orderbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean&>(::lampyris::crypto::protocol::trading::_OrderBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& Response::orderbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.orderBean)
  return _internal_orderbean();
}
inline ::lampyris::crypto::protocol::trading::OrderBean* Response::unsafe_arena_release_orderbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.orderBean)
  if (response_type_case() == kOrderBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.orderbean_;
    _impl_.response_type_.orderbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_orderbean();
    _impl_.response_type_.orderbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.orderBean)
}
inline ::lampyris::crypto::protocol::trading::OrderBean* Response::_internal_mutable_orderbean() {
  if (response_type_case() != kOrderBean) {
    clear_response_type();
    set_has_orderbean();
    _impl_.response_type_.orderbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderBean>(GetArena());
  }
  return _impl_.response_type_.orderbean_;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* Response::mutable_orderbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::OrderBean* _msg = _internal_mutable_orderbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.orderBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.OrderStatusBean orderStatusBean = 34;
inline bool Response::has_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean;
}
inline bool Response::_internal_has_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean;
}
inline void Response::set_has_orderstatusbean() {
  _impl_._oneof_case_[0] = kOrderStatusBean;
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* Response::release_orderstatusbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.orderStatusBean)
  if (response_type_case() == kOrderStatusBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.orderstatusbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.orderstatusbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::OrderStatusBean& Response::_internal_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean ? *_impl_.response_type_.orderstatusbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean&>(::lampyris::crypto::protocol::trading::_OrderStatusBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderStatusBean& Response::orderstatusbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.orderStatusBean)
  return _internal_orderstatusbean();
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* Response::unsafe_arena_release_orderstatusbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.orderStatusBean)
  if (response_type_case() == kOrderStatusBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.orderstatusbean_;
    _impl_.response_type_.orderstatusbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_orderstatusbean(::lampyris::crypto::protocol::trading::OrderStatusBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_orderstatusbean();
    _impl_.response_type_.orderstatusbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.orderStatusBean)
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* Response::_internal_mutable_orderstatusbean() {
  if (response_type_case() != kOrderStatusBean) {
    clear_response_type();
    set_has_orderstatusbean();
    _impl_.response_type_.orderstatusbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderStatusBean>(GetArena());
  }
  return _impl_.response_type_.orderstatusbean_;
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* Response::mutable_orderstatusbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::OrderStatusBean* _msg = _internal_mutable_orderstatusbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.orderStatusBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 35;
inline bool Response::has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline bool Response::_internal_has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline void Response::set_has_resqueryorders() {
  _impl_._oneof_case_[0] = kResQueryOrders;
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::release_resqueryorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::_internal_resqueryorders() const {
  return response_type_case() == kResQueryOrders ? *_impl_.response_type_.resqueryorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders&>(::lampyris::crypto::protocol::trading::_ResQueryOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::resqueryorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _internal_resqueryorders();
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::unsafe_arena_release_resqueryorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryorders_;
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryOrders)
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::_internal_mutable_resqueryorders() {
  if (response_type_case() != kResQueryOrders) {
    clear_response_type();
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryOrders>(GetArena());
  }
  return _impl_.response_type_.resqueryorders_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::mutable_resqueryorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryOrders* _msg = _internal_mutable_resqueryorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.PositionBean positionBean = 36;
inline bool Response::has_positionbean() const {
  return response_type_case() == kPositionBean;
}
inline bool Response::_internal_has_positionbean() const {
  return response_type_case() == kPositionBean;
}
inline void Response::set_has_positionbean() {
  _impl_._oneof_case_[0] = kPositionBean;
}
inline ::lampyris::crypto::protocol::trading::PositionBean* Response::release_positionbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.positionBean)
  if (response_type_case() == kPositionBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.positionbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.positionbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::PositionBean& Response::_internal_positionbean() const {
  return response_type_case() == kPositionBean ? *_impl_.response_type_.positionbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean&>(::lampyris::crypto::protocol::trading::_PositionBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::PositionBean& Response::positionbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.positionBean)
  return _internal_positionbean();
}
inline ::lampyris::crypto::protocol::trading::PositionBean* Response::unsafe_arena_release_positionbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.positionBean)
  if (response_type_case() == kPositionBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.positionbean_;
    _impl_.response_type_.positionbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_positionbean(::lampyris::crypto::protocol::trading::PositionBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_positionbean();
    _impl_.response_type_.positionbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.positionBean)
}
inline ::lampyris::crypto::protocol::trading::PositionBean* Response::_internal_mutable_positionbean() {
  if (response_type_case() != kPositionBean) {
    clear_response_type();
    set_has_positionbean();
    _impl_.response_type_.positionbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::PositionBean>(GetArena());
  }
  return _impl_.response_type_.positionbean_;
}
inline ::lampyris::crypto::protocol::trading::PositionBean* Response::mutable_positionbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::PositionBean* _msg = _internal_mutable_positionbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.positionBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 37;
inline bool Response::has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline bool Response::_internal_has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline void Response::set_has_resquerypositions() {
  _impl_._oneof_case_[0] = kResQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::release_resquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerypositions_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::_internal_resquerypositions() const {
  return response_type_case() == kResQueryPositions ? *_impl_.response_type_.resquerypositions_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions&>(::lampyris::crypto::protocol::trading::_ResQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::resquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _internal_resquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::unsafe_arena_release_resquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerypositions_;
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::_internal_mutable_resquerypositions() {
  if (response_type_case() != kResQueryPositions) {
    clear_response_type();
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryPositions>(GetArena());
  }
  return _impl_.response_type_.resquerypositions_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::mutable_resquerypositions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryPositions* _msg = _internal_mutable_resquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.LeverageBean leverageBean = 38;
inline bool Response::has_leveragebean() const {
  return response_type_case() == kLeverageBean;
}
inline bool Response::_internal_has_leveragebean() const {
  return response_type_case() == kLeverageBean;
}
inline void Response::set_has_leveragebean() {
  _impl_._oneof_case_[0] = kLeverageBean;
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* Response::release_leveragebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.leverageBean)
  if (response_type_case() == kLeverageBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.leveragebean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.leveragebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& Response::_internal_leveragebean() const {
  return response_type_case() == kLeverageBean ? *_impl_.response_type_.leveragebean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean&>(::lampyris::crypto::protocol::trading::_LeverageBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& Response::leveragebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.leverageBean)
  return _internal_leveragebean();
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* Response::unsafe_arena_release_leveragebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.leverageBean)
  if (response_type_case() == kLeverageBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.leveragebean_;
    _impl_.response_type_.leveragebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_leveragebean(::lampyris::crypto::protocol::trading::LeverageBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_leveragebean();
    _impl_.response_type_.leveragebean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.leverageBean)
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* Response::_internal_mutable_leveragebean() {
  if (response_type_case() != kLeverageBean) {
    clear_response_type();
    set_has_leveragebean();
    _impl_.response_type_.leveragebean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::LeverageBean>(GetArena());
  }
  return _impl_.response_type_.leveragebean_;
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* Response::mutable_leveragebean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::LeverageBean* _msg = _internal_mutable_leveragebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.leverageBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 39;
inline bool Response::has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline bool Response::_internal_has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline void Response::set_has_resqueryleverage() {
  _impl_._oneof_case_[0] = kResQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::release_resqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::_internal_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage ? *_impl_.response_type_.resqueryleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage&>(::lampyris::crypto::protocol::trading::_ResQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::resqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _internal_resqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::unsafe_arena_release_resqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleverage_;
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::_internal_mutable_resqueryleverage() {
  if (response_type_case() != kResQueryLeverage) {
    clear_response_type();
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverage>(GetArena());
  }
  return _impl_.response_type_.resqueryleverage_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::mutable_resqueryleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* _msg = _internal_mutable_resqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 40;
inline bool Response::has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline bool Response::_internal_has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline void Response::set_has_resqueryleveragebracket() {
  _impl_._oneof_case_[0] = kResQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleveragebracket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::_internal_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket ? *_impl_.response_type_.resqueryleveragebracket_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ResQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::resqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _internal_resqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::unsafe_arena_release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleveragebracket_;
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::_internal_mutable_resqueryleveragebracket() {
  if (response_type_case() != kResQueryLeverageBracket) {
    clear_response_type();
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket>(GetArena());
  }
  return _impl_.response_type_.resqueryleveragebracket_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::mutable_resqueryleveragebracket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* _msg = _internal_mutable_resqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _msg;
}

// .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean symbolLeverageBracketBean = 41;
inline bool Response::has_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean;
}
inline bool Response::_internal_has_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean;
}
inline void Response::set_has_symbolleveragebracketbean() {
  _impl_._oneof_case_[0] = kSymbolLeverageBracketBean;
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* Response::release_symbolleveragebracketbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  if (response_type_case() == kSymbolLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symbolleveragebracketbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symbolleveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& Response::_internal_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean ? *_impl_.response_type_.symbolleveragebracketbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean&>(::lampyris::crypto::protocol::trading::_SymbolLeverageBracketBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& Response::symbolleveragebracketbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  return _internal_symbolleveragebracketbean();
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* Response::unsafe_arena_release_symbolleveragebracketbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  if (response_type_case() == kSymbolLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.symbolleveragebracketbean_;
    _impl_.response_type_.symbolleveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symbolleveragebracketbean(::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symbolleveragebracketbean();
    _impl_.response_type_.symbolleveragebracketbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* Response::_internal_mutable_symbolleveragebracketbean() {
  if (response_type_case() != kSymbolLeverageBracketBean) {
    clear_response_type();
    set_has_symbolleveragebracketbean();
    _impl_.response_type_.symbolleveragebracketbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>(GetArena());
  }
  return _impl_.response_type_.symbolleveragebracketbean_;
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* Response::mutable_symbolleveragebracketbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* _msg = _internal_mutable_symbolleveragebracketbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.LeverageBracketBean leverageBracketBean = 42;
inline bool Response::has_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean;
}
inline bool Response::_internal_has_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean;
}
inline void Response::set_has_leveragebracketbean() {
  _impl_._oneof_case_[0] = kLeverageBracketBean;
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* Response::release_leveragebracketbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  if (response_type_case() == kLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.leveragebracketbean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.leveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::LeverageBracketBean& Response::_internal_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean ? *_impl_.response_type_.leveragebracketbean_ : reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean&>(::lampyris::crypto::protocol::trading::_LeverageBracketBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::LeverageBracketBean& Response::leveragebracketbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  return _internal_leveragebracketbean();
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* Response::unsafe_arena_release_leveragebracketbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  if (response_type_case() == kLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.leveragebracketbean_;
    _impl_.response_type_.leveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_leveragebracketbean(::lampyris::crypto::protocol::trading::LeverageBracketBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_leveragebracketbean();
    _impl_.response_type_.leveragebracketbean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.leverageBracketBean)
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* Response::_internal_mutable_leveragebracketbean() {
  if (response_type_case() != kLeverageBracketBean) {
    clear_response_type();
    set_has_leveragebracketbean();
    _impl_.response_type_.leveragebracketbean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::LeverageBracketBean>(GetArena());
  }
  return _impl_.response_type_.leveragebracketbean_;
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* Response::mutable_leveragebracketbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* _msg = _internal_mutable_leveragebracketbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  return _msg;
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // common_2eproto_2epb_2eh
