// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: strategy.proto
// Protobuf C++ Version: 5.29.3

#ifndef strategy_2eproto_2epb_2eh
#define strategy_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_strategy_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_strategy_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_strategy_2eproto;
namespace lampyris {
namespace crypto {
namespace protocol {
namespace strategy {
class ReqStrategyAbort;
struct ReqStrategyAbortDefaultTypeInternal;
extern ReqStrategyAbortDefaultTypeInternal _ReqStrategyAbort_default_instance_;
class ReqStrategyAdd;
struct ReqStrategyAddDefaultTypeInternal;
extern ReqStrategyAddDefaultTypeInternal _ReqStrategyAdd_default_instance_;
class ReqStrategyEnableStatus;
struct ReqStrategyEnableStatusDefaultTypeInternal;
extern ReqStrategyEnableStatusDefaultTypeInternal _ReqStrategyEnableStatus_default_instance_;
class ReqStrategyExecutionHistory;
struct ReqStrategyExecutionHistoryDefaultTypeInternal;
extern ReqStrategyExecutionHistoryDefaultTypeInternal _ReqStrategyExecutionHistory_default_instance_;
class ReqStrategyExecutionLog;
struct ReqStrategyExecutionLogDefaultTypeInternal;
extern ReqStrategyExecutionLogDefaultTypeInternal _ReqStrategyExecutionLog_default_instance_;
class ReqStrategyQuery;
struct ReqStrategyQueryDefaultTypeInternal;
extern ReqStrategyQueryDefaultTypeInternal _ReqStrategyQuery_default_instance_;
class ReqStrategyRemove;
struct ReqStrategyRemoveDefaultTypeInternal;
extern ReqStrategyRemoveDefaultTypeInternal _ReqStrategyRemove_default_instance_;
class ReqStrategyUpgrade;
struct ReqStrategyUpgradeDefaultTypeInternal;
extern ReqStrategyUpgradeDefaultTypeInternal _ReqStrategyUpgrade_default_instance_;
class ResStrategyEnableStatus;
struct ResStrategyEnableStatusDefaultTypeInternal;
extern ResStrategyEnableStatusDefaultTypeInternal _ResStrategyEnableStatus_default_instance_;
class ResStrategyExecutionHistory;
struct ResStrategyExecutionHistoryDefaultTypeInternal;
extern ResStrategyExecutionHistoryDefaultTypeInternal _ResStrategyExecutionHistory_default_instance_;
class ResStrategyExecutionLog;
struct ResStrategyExecutionLogDefaultTypeInternal;
extern ResStrategyExecutionLogDefaultTypeInternal _ResStrategyExecutionLog_default_instance_;
class ResStrategyList;
struct ResStrategyListDefaultTypeInternal;
extern ResStrategyListDefaultTypeInternal _ResStrategyList_default_instance_;
class ResStrategyUpgrade;
struct ResStrategyUpgradeDefaultTypeInternal;
extern ResStrategyUpgradeDefaultTypeInternal _ResStrategyUpgrade_default_instance_;
class StrategyAbovePercentageBean;
struct StrategyAbovePercentageBeanDefaultTypeInternal;
extern StrategyAbovePercentageBeanDefaultTypeInternal _StrategyAbovePercentageBean_default_instance_;
class StrategyAbovePercentageMakeProfitBean;
struct StrategyAbovePercentageMakeProfitBeanDefaultTypeInternal;
extern StrategyAbovePercentageMakeProfitBeanDefaultTypeInternal _StrategyAbovePercentageMakeProfitBean_default_instance_;
class StrategyBean;
struct StrategyBeanDefaultTypeInternal;
extern StrategyBeanDefaultTypeInternal _StrategyBean_default_instance_;
class StrategyExecutionHistoryBean;
struct StrategyExecutionHistoryBeanDefaultTypeInternal;
extern StrategyExecutionHistoryBeanDefaultTypeInternal _StrategyExecutionHistoryBean_default_instance_;
}  // namespace strategy
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lampyris {
namespace crypto {
namespace protocol {
namespace strategy {

// ===================================================================


// -------------------------------------------------------------------

class StrategyExecutionHistoryBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean) */ {
 public:
  inline StrategyExecutionHistoryBean() : StrategyExecutionHistoryBean(nullptr) {}
  ~StrategyExecutionHistoryBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrategyExecutionHistoryBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrategyExecutionHistoryBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrategyExecutionHistoryBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline StrategyExecutionHistoryBean(const StrategyExecutionHistoryBean& from) : StrategyExecutionHistoryBean(nullptr, from) {}
  inline StrategyExecutionHistoryBean(StrategyExecutionHistoryBean&& from) noexcept
      : StrategyExecutionHistoryBean(nullptr, std::move(from)) {}
  inline StrategyExecutionHistoryBean& operator=(const StrategyExecutionHistoryBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrategyExecutionHistoryBean& operator=(StrategyExecutionHistoryBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrategyExecutionHistoryBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrategyExecutionHistoryBean* internal_default_instance() {
    return reinterpret_cast<const StrategyExecutionHistoryBean*>(
        &_StrategyExecutionHistoryBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(StrategyExecutionHistoryBean& a, StrategyExecutionHistoryBean& b) { a.Swap(&b); }
  inline void Swap(StrategyExecutionHistoryBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrategyExecutionHistoryBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrategyExecutionHistoryBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrategyExecutionHistoryBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrategyExecutionHistoryBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrategyExecutionHistoryBean& from) { StrategyExecutionHistoryBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrategyExecutionHistoryBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean"; }

 protected:
  explicit StrategyExecutionHistoryBean(::google::protobuf::Arena* arena);
  StrategyExecutionHistoryBean(::google::protobuf::Arena* arena, const StrategyExecutionHistoryBean& from);
  StrategyExecutionHistoryBean(::google::protobuf::Arena* arena, StrategyExecutionHistoryBean&& from) noexcept
      : StrategyExecutionHistoryBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kLastActionFieldNumber = 3,
    kTriggeredTimeFieldNumber = 2,
    kLastActionTimeFieldNumber = 4,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string lastAction = 3;
  void clear_lastaction() ;
  const std::string& lastaction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lastaction(Arg_&& arg, Args_... args);
  std::string* mutable_lastaction();
  PROTOBUF_NODISCARD std::string* release_lastaction();
  void set_allocated_lastaction(std::string* value);

  private:
  const std::string& _internal_lastaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastaction(
      const std::string& value);
  std::string* _internal_mutable_lastaction();

  public:
  // int64 triggeredTime = 2;
  void clear_triggeredtime() ;
  ::int64_t triggeredtime() const;
  void set_triggeredtime(::int64_t value);

  private:
  ::int64_t _internal_triggeredtime() const;
  void _internal_set_triggeredtime(::int64_t value);

  public:
  // int64 lastActionTime = 4;
  void clear_lastactiontime() ;
  ::int64_t lastactiontime() const;
  void set_lastactiontime(::int64_t value);

  private:
  ::int64_t _internal_lastactiontime() const;
  void _internal_set_lastactiontime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      87, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StrategyExecutionHistoryBean& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::ArenaStringPtr lastaction_;
    ::int64_t triggeredtime_;
    ::int64_t lastactiontime_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class StrategyAbovePercentageMakeProfitBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean) */ {
 public:
  inline StrategyAbovePercentageMakeProfitBean() : StrategyAbovePercentageMakeProfitBean(nullptr) {}
  ~StrategyAbovePercentageMakeProfitBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrategyAbovePercentageMakeProfitBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrategyAbovePercentageMakeProfitBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrategyAbovePercentageMakeProfitBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline StrategyAbovePercentageMakeProfitBean(const StrategyAbovePercentageMakeProfitBean& from) : StrategyAbovePercentageMakeProfitBean(nullptr, from) {}
  inline StrategyAbovePercentageMakeProfitBean(StrategyAbovePercentageMakeProfitBean&& from) noexcept
      : StrategyAbovePercentageMakeProfitBean(nullptr, std::move(from)) {}
  inline StrategyAbovePercentageMakeProfitBean& operator=(const StrategyAbovePercentageMakeProfitBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrategyAbovePercentageMakeProfitBean& operator=(StrategyAbovePercentageMakeProfitBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrategyAbovePercentageMakeProfitBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrategyAbovePercentageMakeProfitBean* internal_default_instance() {
    return reinterpret_cast<const StrategyAbovePercentageMakeProfitBean*>(
        &_StrategyAbovePercentageMakeProfitBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(StrategyAbovePercentageMakeProfitBean& a, StrategyAbovePercentageMakeProfitBean& b) { a.Swap(&b); }
  inline void Swap(StrategyAbovePercentageMakeProfitBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrategyAbovePercentageMakeProfitBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrategyAbovePercentageMakeProfitBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrategyAbovePercentageMakeProfitBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrategyAbovePercentageMakeProfitBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrategyAbovePercentageMakeProfitBean& from) { StrategyAbovePercentageMakeProfitBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrategyAbovePercentageMakeProfitBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean"; }

 protected:
  explicit StrategyAbovePercentageMakeProfitBean(::google::protobuf::Arena* arena);
  StrategyAbovePercentageMakeProfitBean(::google::protobuf::Arena* arena, const StrategyAbovePercentageMakeProfitBean& from);
  StrategyAbovePercentageMakeProfitBean(::google::protobuf::Arena* arena, StrategyAbovePercentageMakeProfitBean&& from) noexcept
      : StrategyAbovePercentageMakeProfitBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPercFieldNumber = 1,
    kRatioFieldNumber = 2,
    kMoveStopPercFieldNumber = 3,
    kEnabledFieldNumber = 4,
    kSellOrderIdFieldNumber = 5,
    kMoveSellOrderIdFieldNumber = 6,
  };
  // double perc = 1;
  void clear_perc() ;
  double perc() const;
  void set_perc(double value);

  private:
  double _internal_perc() const;
  void _internal_set_perc(double value);

  public:
  // double ratio = 2;
  void clear_ratio() ;
  double ratio() const;
  void set_ratio(double value);

  private:
  double _internal_ratio() const;
  void _internal_set_ratio(double value);

  public:
  // double moveStopPerc = 3;
  void clear_movestopperc() ;
  double movestopperc() const;
  void set_movestopperc(double value);

  private:
  double _internal_movestopperc() const;
  void _internal_set_movestopperc(double value);

  public:
  // bool enabled = 4;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // int32 sellOrderId = 5;
  void clear_sellorderid() ;
  ::int32_t sellorderid() const;
  void set_sellorderid(::int32_t value);

  private:
  ::int32_t _internal_sellorderid() const;
  void _internal_set_sellorderid(::int32_t value);

  public:
  // int32 moveSellOrderId = 6;
  void clear_movesellorderid() ;
  ::int32_t movesellorderid() const;
  void set_movesellorderid(::int32_t value);

  private:
  ::int32_t _internal_movesellorderid() const;
  void _internal_set_movesellorderid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StrategyAbovePercentageMakeProfitBean& from_msg);
    double perc_;
    double ratio_;
    double movestopperc_;
    bool enabled_;
    ::int32_t sellorderid_;
    ::int32_t movesellorderid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ResStrategyExecutionLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog) */ {
 public:
  inline ResStrategyExecutionLog() : ResStrategyExecutionLog(nullptr) {}
  ~ResStrategyExecutionLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResStrategyExecutionLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResStrategyExecutionLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResStrategyExecutionLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResStrategyExecutionLog(const ResStrategyExecutionLog& from) : ResStrategyExecutionLog(nullptr, from) {}
  inline ResStrategyExecutionLog(ResStrategyExecutionLog&& from) noexcept
      : ResStrategyExecutionLog(nullptr, std::move(from)) {}
  inline ResStrategyExecutionLog& operator=(const ResStrategyExecutionLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResStrategyExecutionLog& operator=(ResStrategyExecutionLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResStrategyExecutionLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResStrategyExecutionLog* internal_default_instance() {
    return reinterpret_cast<const ResStrategyExecutionLog*>(
        &_ResStrategyExecutionLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ResStrategyExecutionLog& a, ResStrategyExecutionLog& b) { a.Swap(&b); }
  inline void Swap(ResStrategyExecutionLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResStrategyExecutionLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResStrategyExecutionLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResStrategyExecutionLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResStrategyExecutionLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResStrategyExecutionLog& from) { ResStrategyExecutionLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResStrategyExecutionLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ResStrategyExecutionLog"; }

 protected:
  explicit ResStrategyExecutionLog(::google::protobuf::Arena* arena);
  ResStrategyExecutionLog(::google::protobuf::Arena* arena, const ResStrategyExecutionLog& from);
  ResStrategyExecutionLog(::google::protobuf::Arena* arena, ResStrategyExecutionLog&& from) noexcept
      : ResStrategyExecutionLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogListFieldNumber = 1,
    kIsIncrementFieldNumber = 2,
  };
  // repeated string logList = 1;
  int loglist_size() const;
  private:
  int _internal_loglist_size() const;

  public:
  void clear_loglist() ;
  const std::string& loglist(int index) const;
  std::string* mutable_loglist(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_loglist(int index, Arg_&& value, Args_... args);
  std::string* add_loglist();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_loglist(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& loglist() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_loglist();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_loglist() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_loglist();

  public:
  // bool isIncrement = 2;
  void clear_isincrement() ;
  bool isincrement() const;
  void set_isincrement(bool value);

  private:
  bool _internal_isincrement() const;
  void _internal_set_isincrement(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResStrategyExecutionLog& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> loglist_;
    bool isincrement_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ResStrategyEnableStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus) */ {
 public:
  inline ResStrategyEnableStatus() : ResStrategyEnableStatus(nullptr) {}
  ~ResStrategyEnableStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResStrategyEnableStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResStrategyEnableStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResStrategyEnableStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResStrategyEnableStatus(const ResStrategyEnableStatus& from) : ResStrategyEnableStatus(nullptr, from) {}
  inline ResStrategyEnableStatus(ResStrategyEnableStatus&& from) noexcept
      : ResStrategyEnableStatus(nullptr, std::move(from)) {}
  inline ResStrategyEnableStatus& operator=(const ResStrategyEnableStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResStrategyEnableStatus& operator=(ResStrategyEnableStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResStrategyEnableStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResStrategyEnableStatus* internal_default_instance() {
    return reinterpret_cast<const ResStrategyEnableStatus*>(
        &_ResStrategyEnableStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ResStrategyEnableStatus& a, ResStrategyEnableStatus& b) { a.Swap(&b); }
  inline void Swap(ResStrategyEnableStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResStrategyEnableStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResStrategyEnableStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResStrategyEnableStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResStrategyEnableStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResStrategyEnableStatus& from) { ResStrategyEnableStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResStrategyEnableStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ResStrategyEnableStatus"; }

 protected:
  explicit ResStrategyEnableStatus(::google::protobuf::Arena* arena);
  ResStrategyEnableStatus(::google::protobuf::Arena* arena, const ResStrategyEnableStatus& from);
  ResStrategyEnableStatus(::google::protobuf::Arena* arena, ResStrategyEnableStatus&& from) noexcept
      : ResStrategyEnableStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrategyUIdFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // int32 strategyUId = 1;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResStrategyEnableStatus& from_msg);
    ::int32_t strategyuid_;
    bool enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyRemove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyRemove) */ {
 public:
  inline ReqStrategyRemove() : ReqStrategyRemove(nullptr) {}
  ~ReqStrategyRemove() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyRemove* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyRemove));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyRemove(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyRemove(const ReqStrategyRemove& from) : ReqStrategyRemove(nullptr, from) {}
  inline ReqStrategyRemove(ReqStrategyRemove&& from) noexcept
      : ReqStrategyRemove(nullptr, std::move(from)) {}
  inline ReqStrategyRemove& operator=(const ReqStrategyRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyRemove& operator=(ReqStrategyRemove&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyRemove& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyRemove* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyRemove*>(
        &_ReqStrategyRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ReqStrategyRemove& a, ReqStrategyRemove& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyRemove* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyRemove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyRemove* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyRemove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyRemove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyRemove& from) { ReqStrategyRemove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyRemove* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyRemove"; }

 protected:
  explicit ReqStrategyRemove(::google::protobuf::Arena* arena);
  ReqStrategyRemove(::google::protobuf::Arena* arena, const ReqStrategyRemove& from);
  ReqStrategyRemove(::google::protobuf::Arena* arena, ReqStrategyRemove&& from) noexcept
      : ReqStrategyRemove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrategyUIdFieldNumber = 1,
  };
  // int32 strategyUId = 1;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyRemove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyRemove& from_msg);
    ::int32_t strategyuid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyQuery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyQuery) */ {
 public:
  inline ReqStrategyQuery() : ReqStrategyQuery(nullptr) {}
  ~ReqStrategyQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyQuery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyQuery(const ReqStrategyQuery& from) : ReqStrategyQuery(nullptr, from) {}
  inline ReqStrategyQuery(ReqStrategyQuery&& from) noexcept
      : ReqStrategyQuery(nullptr, std::move(from)) {}
  inline ReqStrategyQuery& operator=(const ReqStrategyQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyQuery& operator=(ReqStrategyQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyQuery* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyQuery*>(
        &_ReqStrategyQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ReqStrategyQuery& a, ReqStrategyQuery& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyQuery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyQuery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyQuery& from) { ReqStrategyQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyQuery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyQuery"; }

 protected:
  explicit ReqStrategyQuery(::google::protobuf::Arena* arena);
  ReqStrategyQuery(::google::protobuf::Arena* arena, const ReqStrategyQuery& from);
  ReqStrategyQuery(::google::protobuf::Arena* arena, ReqStrategyQuery&& from) noexcept
      : ReqStrategyQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyQuery& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyExecutionLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog) */ {
 public:
  inline ReqStrategyExecutionLog() : ReqStrategyExecutionLog(nullptr) {}
  ~ReqStrategyExecutionLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyExecutionLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyExecutionLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyExecutionLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyExecutionLog(const ReqStrategyExecutionLog& from) : ReqStrategyExecutionLog(nullptr, from) {}
  inline ReqStrategyExecutionLog(ReqStrategyExecutionLog&& from) noexcept
      : ReqStrategyExecutionLog(nullptr, std::move(from)) {}
  inline ReqStrategyExecutionLog& operator=(const ReqStrategyExecutionLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyExecutionLog& operator=(ReqStrategyExecutionLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyExecutionLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyExecutionLog* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyExecutionLog*>(
        &_ReqStrategyExecutionLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReqStrategyExecutionLog& a, ReqStrategyExecutionLog& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyExecutionLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyExecutionLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyExecutionLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyExecutionLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyExecutionLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyExecutionLog& from) { ReqStrategyExecutionLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyExecutionLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog"; }

 protected:
  explicit ReqStrategyExecutionLog(::google::protobuf::Arena* arena);
  ReqStrategyExecutionLog(::google::protobuf::Arena* arena, const ReqStrategyExecutionLog& from);
  ReqStrategyExecutionLog(::google::protobuf::Arena* arena, ReqStrategyExecutionLog&& from) noexcept
      : ReqStrategyExecutionLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrategyUIdFieldNumber = 1,
  };
  // int32 strategyUId = 1;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyExecutionLog& from_msg);
    ::int32_t strategyuid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyExecutionHistory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory) */ {
 public:
  inline ReqStrategyExecutionHistory() : ReqStrategyExecutionHistory(nullptr) {}
  ~ReqStrategyExecutionHistory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyExecutionHistory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyExecutionHistory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyExecutionHistory(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyExecutionHistory(const ReqStrategyExecutionHistory& from) : ReqStrategyExecutionHistory(nullptr, from) {}
  inline ReqStrategyExecutionHistory(ReqStrategyExecutionHistory&& from) noexcept
      : ReqStrategyExecutionHistory(nullptr, std::move(from)) {}
  inline ReqStrategyExecutionHistory& operator=(const ReqStrategyExecutionHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyExecutionHistory& operator=(ReqStrategyExecutionHistory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyExecutionHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyExecutionHistory* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyExecutionHistory*>(
        &_ReqStrategyExecutionHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ReqStrategyExecutionHistory& a, ReqStrategyExecutionHistory& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyExecutionHistory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyExecutionHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyExecutionHistory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyExecutionHistory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyExecutionHistory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyExecutionHistory& from) { ReqStrategyExecutionHistory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyExecutionHistory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory"; }

 protected:
  explicit ReqStrategyExecutionHistory(::google::protobuf::Arena* arena);
  ReqStrategyExecutionHistory(::google::protobuf::Arena* arena, const ReqStrategyExecutionHistory& from);
  ReqStrategyExecutionHistory(::google::protobuf::Arena* arena, ReqStrategyExecutionHistory&& from) noexcept
      : ReqStrategyExecutionHistory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      76, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyExecutionHistory& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyEnableStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus) */ {
 public:
  inline ReqStrategyEnableStatus() : ReqStrategyEnableStatus(nullptr) {}
  ~ReqStrategyEnableStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyEnableStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyEnableStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyEnableStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyEnableStatus(const ReqStrategyEnableStatus& from) : ReqStrategyEnableStatus(nullptr, from) {}
  inline ReqStrategyEnableStatus(ReqStrategyEnableStatus&& from) noexcept
      : ReqStrategyEnableStatus(nullptr, std::move(from)) {}
  inline ReqStrategyEnableStatus& operator=(const ReqStrategyEnableStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyEnableStatus& operator=(ReqStrategyEnableStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyEnableStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyEnableStatus* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyEnableStatus*>(
        &_ReqStrategyEnableStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ReqStrategyEnableStatus& a, ReqStrategyEnableStatus& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyEnableStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyEnableStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyEnableStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyEnableStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyEnableStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyEnableStatus& from) { ReqStrategyEnableStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyEnableStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus"; }

 protected:
  explicit ReqStrategyEnableStatus(::google::protobuf::Arena* arena);
  ReqStrategyEnableStatus(::google::protobuf::Arena* arena, const ReqStrategyEnableStatus& from);
  ReqStrategyEnableStatus(::google::protobuf::Arena* arena, ReqStrategyEnableStatus&& from) noexcept
      : ReqStrategyEnableStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrategyUIdFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // int32 strategyUId = 1;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyEnableStatus& from_msg);
    ::int32_t strategyuid_;
    bool enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyAbort final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyAbort) */ {
 public:
  inline ReqStrategyAbort() : ReqStrategyAbort(nullptr) {}
  ~ReqStrategyAbort() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyAbort* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyAbort));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyAbort(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyAbort(const ReqStrategyAbort& from) : ReqStrategyAbort(nullptr, from) {}
  inline ReqStrategyAbort(ReqStrategyAbort&& from) noexcept
      : ReqStrategyAbort(nullptr, std::move(from)) {}
  inline ReqStrategyAbort& operator=(const ReqStrategyAbort& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyAbort& operator=(ReqStrategyAbort&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyAbort& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyAbort* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyAbort*>(
        &_ReqStrategyAbort_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReqStrategyAbort& a, ReqStrategyAbort& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyAbort* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyAbort* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyAbort* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyAbort>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyAbort& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyAbort& from) { ReqStrategyAbort::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyAbort* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyAbort"; }

 protected:
  explicit ReqStrategyAbort(::google::protobuf::Arena* arena);
  ReqStrategyAbort(::google::protobuf::Arena* arena, const ReqStrategyAbort& from);
  ReqStrategyAbort(::google::protobuf::Arena* arena, ReqStrategyAbort&& from) noexcept
      : ReqStrategyAbort(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamFieldNumber = 2,
    kStrategyUIdFieldNumber = 1,
  };
  // string param = 2;
  void clear_param() ;
  const std::string& param() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param(Arg_&& arg, Args_... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* value);

  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(
      const std::string& value);
  std::string* _internal_mutable_param();

  public:
  // int32 strategyUId = 1;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyAbort)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyAbort& from_msg);
    ::google::protobuf::internal::ArenaStringPtr param_;
    ::int32_t strategyuid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class StrategyAbovePercentageBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean) */ {
 public:
  inline StrategyAbovePercentageBean() : StrategyAbovePercentageBean(nullptr) {}
  ~StrategyAbovePercentageBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrategyAbovePercentageBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrategyAbovePercentageBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrategyAbovePercentageBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline StrategyAbovePercentageBean(const StrategyAbovePercentageBean& from) : StrategyAbovePercentageBean(nullptr, from) {}
  inline StrategyAbovePercentageBean(StrategyAbovePercentageBean&& from) noexcept
      : StrategyAbovePercentageBean(nullptr, std::move(from)) {}
  inline StrategyAbovePercentageBean& operator=(const StrategyAbovePercentageBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrategyAbovePercentageBean& operator=(StrategyAbovePercentageBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrategyAbovePercentageBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrategyAbovePercentageBean* internal_default_instance() {
    return reinterpret_cast<const StrategyAbovePercentageBean*>(
        &_StrategyAbovePercentageBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(StrategyAbovePercentageBean& a, StrategyAbovePercentageBean& b) { a.Swap(&b); }
  inline void Swap(StrategyAbovePercentageBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrategyAbovePercentageBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrategyAbovePercentageBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrategyAbovePercentageBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrategyAbovePercentageBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrategyAbovePercentageBean& from) { StrategyAbovePercentageBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrategyAbovePercentageBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean"; }

 protected:
  explicit StrategyAbovePercentageBean(::google::protobuf::Arena* arena);
  StrategyAbovePercentageBean(::google::protobuf::Arena* arena, const StrategyAbovePercentageBean& from);
  StrategyAbovePercentageBean(::google::protobuf::Arena* arena, StrategyAbovePercentageBean&& from) noexcept
      : StrategyAbovePercentageBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMakeProfitBeanListFieldNumber = 5,
    kTriggerPercFieldNumber = 1,
    kStopLossPercFieldNumber = 2,
    kBuyRatioFieldNumber = 3,
    kBuyMoneyFieldNumber = 4,
  };
  // repeated .lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean makeProfitBeanList = 5;
  int makeprofitbeanlist_size() const;
  private:
  int _internal_makeprofitbeanlist_size() const;

  public:
  void clear_makeprofitbeanlist() ;
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean* mutable_makeprofitbeanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>* mutable_makeprofitbeanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>& _internal_makeprofitbeanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>* _internal_mutable_makeprofitbeanlist();
  public:
  const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean& makeprofitbeanlist(int index) const;
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean* add_makeprofitbeanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>& makeprofitbeanlist() const;
  // double triggerPerc = 1;
  void clear_triggerperc() ;
  double triggerperc() const;
  void set_triggerperc(double value);

  private:
  double _internal_triggerperc() const;
  void _internal_set_triggerperc(double value);

  public:
  // optional double stopLossPerc = 2;
  bool has_stoplossperc() const;
  void clear_stoplossperc() ;
  double stoplossperc() const;
  void set_stoplossperc(double value);

  private:
  double _internal_stoplossperc() const;
  void _internal_set_stoplossperc(double value);

  public:
  // optional double buyRatio = 3;
  bool has_buyratio() const;
  void clear_buyratio() ;
  double buyratio() const;
  void set_buyratio(double value);

  private:
  double _internal_buyratio() const;
  void _internal_set_buyratio(double value);

  public:
  // optional double buyMoney = 4;
  bool has_buymoney() const;
  void clear_buymoney() ;
  double buymoney() const;
  void set_buymoney(double value);

  private:
  double _internal_buymoney() const;
  void _internal_set_buymoney(double value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StrategyAbovePercentageBean& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean > makeprofitbeanlist_;
    double triggerperc_;
    double stoplossperc_;
    double buyratio_;
    double buymoney_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ResStrategyExecutionHistory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory) */ {
 public:
  inline ResStrategyExecutionHistory() : ResStrategyExecutionHistory(nullptr) {}
  ~ResStrategyExecutionHistory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResStrategyExecutionHistory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResStrategyExecutionHistory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResStrategyExecutionHistory(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResStrategyExecutionHistory(const ResStrategyExecutionHistory& from) : ResStrategyExecutionHistory(nullptr, from) {}
  inline ResStrategyExecutionHistory(ResStrategyExecutionHistory&& from) noexcept
      : ResStrategyExecutionHistory(nullptr, std::move(from)) {}
  inline ResStrategyExecutionHistory& operator=(const ResStrategyExecutionHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResStrategyExecutionHistory& operator=(ResStrategyExecutionHistory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResStrategyExecutionHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResStrategyExecutionHistory* internal_default_instance() {
    return reinterpret_cast<const ResStrategyExecutionHistory*>(
        &_ResStrategyExecutionHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ResStrategyExecutionHistory& a, ResStrategyExecutionHistory& b) { a.Swap(&b); }
  inline void Swap(ResStrategyExecutionHistory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResStrategyExecutionHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResStrategyExecutionHistory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResStrategyExecutionHistory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResStrategyExecutionHistory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResStrategyExecutionHistory& from) { ResStrategyExecutionHistory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResStrategyExecutionHistory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory"; }

 protected:
  explicit ResStrategyExecutionHistory(::google::protobuf::Arena* arena);
  ResStrategyExecutionHistory(::google::protobuf::Arena* arena, const ResStrategyExecutionHistory& from);
  ResStrategyExecutionHistory(::google::protobuf::Arena* arena, ResStrategyExecutionHistory&& from) noexcept
      : ResStrategyExecutionHistory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResStrategyExecutionHistory& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class StrategyBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.StrategyBean) */ {
 public:
  inline StrategyBean() : StrategyBean(nullptr) {}
  ~StrategyBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StrategyBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StrategyBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StrategyBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline StrategyBean(const StrategyBean& from) : StrategyBean(nullptr, from) {}
  inline StrategyBean(StrategyBean&& from) noexcept
      : StrategyBean(nullptr, std::move(from)) {}
  inline StrategyBean& operator=(const StrategyBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrategyBean& operator=(StrategyBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrategyBean& default_instance() {
    return *internal_default_instance();
  }
  enum ImplementBeanCase {
    kStrategyAbovePercentageBean = 7,
    IMPLEMENTBEAN_NOT_SET = 0,
  };
  static inline const StrategyBean* internal_default_instance() {
    return reinterpret_cast<const StrategyBean*>(
        &_StrategyBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(StrategyBean& a, StrategyBean& b) { a.Swap(&b); }
  inline void Swap(StrategyBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrategyBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrategyBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StrategyBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrategyBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StrategyBean& from) { StrategyBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StrategyBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.StrategyBean"; }

 protected:
  explicit StrategyBean(::google::protobuf::Arena* arena);
  StrategyBean(::google::protobuf::Arena* arena, const StrategyBean& from);
  StrategyBean(::google::protobuf::Arena* arena, StrategyBean&& from) noexcept
      : StrategyBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBannedSymbolListFieldNumber = 3,
    kSymbolFieldNumber = 1,
    kTimeInForceParamFieldNumber = 5,
    kEnabledFieldNumber = 2,
    kStrategyUIDFieldNumber = 4,
    kStatusFieldNumber = 6,
    kStrategyAbovePercentageBeanFieldNumber = 7,
  };
  // repeated string bannedSymbolList = 3;
  int bannedsymbollist_size() const;
  private:
  int _internal_bannedsymbollist_size() const;

  public:
  void clear_bannedsymbollist() ;
  const std::string& bannedsymbollist(int index) const;
  std::string* mutable_bannedsymbollist(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bannedsymbollist(int index, Arg_&& value, Args_... args);
  std::string* add_bannedsymbollist();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_bannedsymbollist(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& bannedsymbollist() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_bannedsymbollist();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_bannedsymbollist() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_bannedsymbollist();

  public:
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string timeInForceParam = 5;
  void clear_timeinforceparam() ;
  const std::string& timeinforceparam() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timeinforceparam(Arg_&& arg, Args_... args);
  std::string* mutable_timeinforceparam();
  PROTOBUF_NODISCARD std::string* release_timeinforceparam();
  void set_allocated_timeinforceparam(std::string* value);

  private:
  const std::string& _internal_timeinforceparam() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeinforceparam(
      const std::string& value);
  std::string* _internal_mutable_timeinforceparam();

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // optional int32 strategyUID = 4;
  bool has_strategyuid() const;
  void clear_strategyuid() ;
  ::int32_t strategyuid() const;
  void set_strategyuid(::int32_t value);

  private:
  ::int32_t _internal_strategyuid() const;
  void _internal_set_strategyuid(::int32_t value);

  public:
  // int32 status = 6;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // .lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean strategyAbovePercentageBean = 7;
  bool has_strategyabovepercentagebean() const;
  private:
  bool _internal_has_strategyabovepercentagebean() const;

  public:
  void clear_strategyabovepercentagebean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean& strategyabovepercentagebean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* release_strategyabovepercentagebean();
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* mutable_strategyabovepercentagebean();
  void set_allocated_strategyabovepercentagebean(::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* value);
  void unsafe_arena_set_allocated_strategyabovepercentagebean(::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* value);
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* unsafe_arena_release_strategyabovepercentagebean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean& _internal_strategyabovepercentagebean() const;
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* _internal_mutable_strategyabovepercentagebean();

  public:
  void clear_ImplementBean();
  ImplementBeanCase ImplementBean_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.StrategyBean)
 private:
  class _Internal;
  void set_has_strategyabovepercentagebean();
  inline bool has_ImplementBean() const;
  inline void clear_has_ImplementBean();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      93, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StrategyBean& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> bannedsymbollist_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::ArenaStringPtr timeinforceparam_;
    bool enabled_;
    ::int32_t strategyuid_;
    ::int32_t status_;
    union ImplementBeanUnion {
      constexpr ImplementBeanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* strategyabovepercentagebean_;
    } ImplementBean_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ResStrategyUpgrade final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ResStrategyUpgrade) */ {
 public:
  inline ResStrategyUpgrade() : ResStrategyUpgrade(nullptr) {}
  ~ResStrategyUpgrade() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResStrategyUpgrade* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResStrategyUpgrade));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResStrategyUpgrade(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResStrategyUpgrade(const ResStrategyUpgrade& from) : ResStrategyUpgrade(nullptr, from) {}
  inline ResStrategyUpgrade(ResStrategyUpgrade&& from) noexcept
      : ResStrategyUpgrade(nullptr, std::move(from)) {}
  inline ResStrategyUpgrade& operator=(const ResStrategyUpgrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResStrategyUpgrade& operator=(ResStrategyUpgrade&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResStrategyUpgrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResStrategyUpgrade* internal_default_instance() {
    return reinterpret_cast<const ResStrategyUpgrade*>(
        &_ResStrategyUpgrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ResStrategyUpgrade& a, ResStrategyUpgrade& b) { a.Swap(&b); }
  inline void Swap(ResStrategyUpgrade* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResStrategyUpgrade* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResStrategyUpgrade* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResStrategyUpgrade>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResStrategyUpgrade& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResStrategyUpgrade& from) { ResStrategyUpgrade::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResStrategyUpgrade* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ResStrategyUpgrade"; }

 protected:
  explicit ResStrategyUpgrade(::google::protobuf::Arena* arena);
  ResStrategyUpgrade(::google::protobuf::Arena* arena, const ResStrategyUpgrade& from);
  ResStrategyUpgrade(::google::protobuf::Arena* arena, ResStrategyUpgrade&& from) noexcept
      : ResStrategyUpgrade(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanFieldNumber = 1,
  };
  // .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
  bool has_bean() const;
  void clear_bean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyBean& bean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StrategyBean* release_bean();
  ::lampyris::crypto::protocol::strategy::StrategyBean* mutable_bean();
  void set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  void unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  ::lampyris::crypto::protocol::strategy::StrategyBean* unsafe_arena_release_bean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyBean& _internal_bean() const;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _internal_mutable_bean();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ResStrategyUpgrade)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResStrategyUpgrade& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::strategy::StrategyBean* bean_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ResStrategyList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ResStrategyList) */ {
 public:
  inline ResStrategyList() : ResStrategyList(nullptr) {}
  ~ResStrategyList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResStrategyList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResStrategyList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResStrategyList(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResStrategyList(const ResStrategyList& from) : ResStrategyList(nullptr, from) {}
  inline ResStrategyList(ResStrategyList&& from) noexcept
      : ResStrategyList(nullptr, std::move(from)) {}
  inline ResStrategyList& operator=(const ResStrategyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResStrategyList& operator=(ResStrategyList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResStrategyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResStrategyList* internal_default_instance() {
    return reinterpret_cast<const ResStrategyList*>(
        &_ResStrategyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ResStrategyList& a, ResStrategyList& b) { a.Swap(&b); }
  inline void Swap(ResStrategyList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResStrategyList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResStrategyList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResStrategyList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResStrategyList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResStrategyList& from) { ResStrategyList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResStrategyList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ResStrategyList"; }

 protected:
  explicit ResStrategyList(::google::protobuf::Arena* arena);
  ResStrategyList(::google::protobuf::Arena* arena, const ResStrategyList& from);
  ResStrategyList(::google::protobuf::Arena* arena, ResStrategyList&& from) noexcept
      : ResStrategyList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.strategy.StrategyBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::strategy::StrategyBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::strategy::StrategyBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::strategy::StrategyBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ResStrategyList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResStrategyList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::strategy::StrategyBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyUpgrade final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade) */ {
 public:
  inline ReqStrategyUpgrade() : ReqStrategyUpgrade(nullptr) {}
  ~ReqStrategyUpgrade() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyUpgrade* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyUpgrade));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyUpgrade(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyUpgrade(const ReqStrategyUpgrade& from) : ReqStrategyUpgrade(nullptr, from) {}
  inline ReqStrategyUpgrade(ReqStrategyUpgrade&& from) noexcept
      : ReqStrategyUpgrade(nullptr, std::move(from)) {}
  inline ReqStrategyUpgrade& operator=(const ReqStrategyUpgrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyUpgrade& operator=(ReqStrategyUpgrade&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyUpgrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyUpgrade* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyUpgrade*>(
        &_ReqStrategyUpgrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ReqStrategyUpgrade& a, ReqStrategyUpgrade& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyUpgrade* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyUpgrade* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyUpgrade* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyUpgrade>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyUpgrade& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyUpgrade& from) { ReqStrategyUpgrade::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyUpgrade* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyUpgrade"; }

 protected:
  explicit ReqStrategyUpgrade(::google::protobuf::Arena* arena);
  ReqStrategyUpgrade(::google::protobuf::Arena* arena, const ReqStrategyUpgrade& from);
  ReqStrategyUpgrade(::google::protobuf::Arena* arena, ReqStrategyUpgrade&& from) noexcept
      : ReqStrategyUpgrade(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanFieldNumber = 1,
  };
  // .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
  bool has_bean() const;
  void clear_bean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyBean& bean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StrategyBean* release_bean();
  ::lampyris::crypto::protocol::strategy::StrategyBean* mutable_bean();
  void set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  void unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  ::lampyris::crypto::protocol::strategy::StrategyBean* unsafe_arena_release_bean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyBean& _internal_bean() const;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _internal_mutable_bean();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyUpgrade& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::strategy::StrategyBean* bean_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};
// -------------------------------------------------------------------

class ReqStrategyAdd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.strategy.ReqStrategyAdd) */ {
 public:
  inline ReqStrategyAdd() : ReqStrategyAdd(nullptr) {}
  ~ReqStrategyAdd() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqStrategyAdd* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqStrategyAdd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqStrategyAdd(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqStrategyAdd(const ReqStrategyAdd& from) : ReqStrategyAdd(nullptr, from) {}
  inline ReqStrategyAdd(ReqStrategyAdd&& from) noexcept
      : ReqStrategyAdd(nullptr, std::move(from)) {}
  inline ReqStrategyAdd& operator=(const ReqStrategyAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqStrategyAdd& operator=(ReqStrategyAdd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqStrategyAdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqStrategyAdd* internal_default_instance() {
    return reinterpret_cast<const ReqStrategyAdd*>(
        &_ReqStrategyAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ReqStrategyAdd& a, ReqStrategyAdd& b) { a.Swap(&b); }
  inline void Swap(ReqStrategyAdd* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqStrategyAdd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqStrategyAdd* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqStrategyAdd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqStrategyAdd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqStrategyAdd& from) { ReqStrategyAdd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqStrategyAdd* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.strategy.ReqStrategyAdd"; }

 protected:
  explicit ReqStrategyAdd(::google::protobuf::Arena* arena);
  ReqStrategyAdd(::google::protobuf::Arena* arena, const ReqStrategyAdd& from);
  ReqStrategyAdd(::google::protobuf::Arena* arena, ReqStrategyAdd&& from) noexcept
      : ReqStrategyAdd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanFieldNumber = 1,
  };
  // .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
  bool has_bean() const;
  void clear_bean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyBean& bean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::StrategyBean* release_bean();
  ::lampyris::crypto::protocol::strategy::StrategyBean* mutable_bean();
  void set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  void unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value);
  ::lampyris::crypto::protocol::strategy::StrategyBean* unsafe_arena_release_bean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyBean& _internal_bean() const;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _internal_mutable_bean();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.strategy.ReqStrategyAdd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqStrategyAdd& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::strategy::StrategyBean* bean_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StrategyAbovePercentageMakeProfitBean

// double perc = 1;
inline void StrategyAbovePercentageMakeProfitBean::clear_perc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.perc_ = 0;
}
inline double StrategyAbovePercentageMakeProfitBean::perc() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.perc)
  return _internal_perc();
}
inline void StrategyAbovePercentageMakeProfitBean::set_perc(double value) {
  _internal_set_perc(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.perc)
}
inline double StrategyAbovePercentageMakeProfitBean::_internal_perc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.perc_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_perc(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.perc_ = value;
}

// double ratio = 2;
inline void StrategyAbovePercentageMakeProfitBean::clear_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ratio_ = 0;
}
inline double StrategyAbovePercentageMakeProfitBean::ratio() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.ratio)
  return _internal_ratio();
}
inline void StrategyAbovePercentageMakeProfitBean::set_ratio(double value) {
  _internal_set_ratio(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.ratio)
}
inline double StrategyAbovePercentageMakeProfitBean::_internal_ratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ratio_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_ratio(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ratio_ = value;
}

// double moveStopPerc = 3;
inline void StrategyAbovePercentageMakeProfitBean::clear_movestopperc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movestopperc_ = 0;
}
inline double StrategyAbovePercentageMakeProfitBean::movestopperc() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.moveStopPerc)
  return _internal_movestopperc();
}
inline void StrategyAbovePercentageMakeProfitBean::set_movestopperc(double value) {
  _internal_set_movestopperc(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.moveStopPerc)
}
inline double StrategyAbovePercentageMakeProfitBean::_internal_movestopperc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movestopperc_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_movestopperc(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movestopperc_ = value;
}

// bool enabled = 4;
inline void StrategyAbovePercentageMakeProfitBean::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool StrategyAbovePercentageMakeProfitBean::enabled() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.enabled)
  return _internal_enabled();
}
inline void StrategyAbovePercentageMakeProfitBean::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.enabled)
}
inline bool StrategyAbovePercentageMakeProfitBean::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// int32 sellOrderId = 5;
inline void StrategyAbovePercentageMakeProfitBean::clear_sellorderid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sellorderid_ = 0;
}
inline ::int32_t StrategyAbovePercentageMakeProfitBean::sellorderid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.sellOrderId)
  return _internal_sellorderid();
}
inline void StrategyAbovePercentageMakeProfitBean::set_sellorderid(::int32_t value) {
  _internal_set_sellorderid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.sellOrderId)
}
inline ::int32_t StrategyAbovePercentageMakeProfitBean::_internal_sellorderid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sellorderid_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_sellorderid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sellorderid_ = value;
}

// int32 moveSellOrderId = 6;
inline void StrategyAbovePercentageMakeProfitBean::clear_movesellorderid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movesellorderid_ = 0;
}
inline ::int32_t StrategyAbovePercentageMakeProfitBean::movesellorderid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.moveSellOrderId)
  return _internal_movesellorderid();
}
inline void StrategyAbovePercentageMakeProfitBean::set_movesellorderid(::int32_t value) {
  _internal_set_movesellorderid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean.moveSellOrderId)
}
inline ::int32_t StrategyAbovePercentageMakeProfitBean::_internal_movesellorderid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movesellorderid_;
}
inline void StrategyAbovePercentageMakeProfitBean::_internal_set_movesellorderid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movesellorderid_ = value;
}

// -------------------------------------------------------------------

// StrategyAbovePercentageBean

// double triggerPerc = 1;
inline void StrategyAbovePercentageBean::clear_triggerperc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggerperc_ = 0;
}
inline double StrategyAbovePercentageBean::triggerperc() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.triggerPerc)
  return _internal_triggerperc();
}
inline void StrategyAbovePercentageBean::set_triggerperc(double value) {
  _internal_set_triggerperc(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.triggerPerc)
}
inline double StrategyAbovePercentageBean::_internal_triggerperc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triggerperc_;
}
inline void StrategyAbovePercentageBean::_internal_set_triggerperc(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggerperc_ = value;
}

// optional double stopLossPerc = 2;
inline bool StrategyAbovePercentageBean::has_stoplossperc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StrategyAbovePercentageBean::clear_stoplossperc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stoplossperc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double StrategyAbovePercentageBean::stoplossperc() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.stopLossPerc)
  return _internal_stoplossperc();
}
inline void StrategyAbovePercentageBean::set_stoplossperc(double value) {
  _internal_set_stoplossperc(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.stopLossPerc)
}
inline double StrategyAbovePercentageBean::_internal_stoplossperc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stoplossperc_;
}
inline void StrategyAbovePercentageBean::_internal_set_stoplossperc(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stoplossperc_ = value;
}

// optional double buyRatio = 3;
inline bool StrategyAbovePercentageBean::has_buyratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StrategyAbovePercentageBean::clear_buyratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buyratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double StrategyAbovePercentageBean::buyratio() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.buyRatio)
  return _internal_buyratio();
}
inline void StrategyAbovePercentageBean::set_buyratio(double value) {
  _internal_set_buyratio(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.buyRatio)
}
inline double StrategyAbovePercentageBean::_internal_buyratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buyratio_;
}
inline void StrategyAbovePercentageBean::_internal_set_buyratio(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buyratio_ = value;
}

// optional double buyMoney = 4;
inline bool StrategyAbovePercentageBean::has_buymoney() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StrategyAbovePercentageBean::clear_buymoney() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buymoney_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double StrategyAbovePercentageBean::buymoney() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.buyMoney)
  return _internal_buymoney();
}
inline void StrategyAbovePercentageBean::set_buymoney(double value) {
  _internal_set_buymoney(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.buyMoney)
}
inline double StrategyAbovePercentageBean::_internal_buymoney() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buymoney_;
}
inline void StrategyAbovePercentageBean::_internal_set_buymoney(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buymoney_ = value;
}

// repeated .lampyris.crypto.protocol.strategy.StrategyAbovePercentageMakeProfitBean makeProfitBeanList = 5;
inline int StrategyAbovePercentageBean::_internal_makeprofitbeanlist_size() const {
  return _internal_makeprofitbeanlist().size();
}
inline int StrategyAbovePercentageBean::makeprofitbeanlist_size() const {
  return _internal_makeprofitbeanlist_size();
}
inline void StrategyAbovePercentageBean::clear_makeprofitbeanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.makeprofitbeanlist_.Clear();
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean* StrategyAbovePercentageBean::mutable_makeprofitbeanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.makeProfitBeanList)
  return _internal_mutable_makeprofitbeanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>* StrategyAbovePercentageBean::mutable_makeprofitbeanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.makeProfitBeanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_makeprofitbeanlist();
}
inline const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean& StrategyAbovePercentageBean::makeprofitbeanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.makeProfitBeanList)
  return _internal_makeprofitbeanlist().Get(index);
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean* StrategyAbovePercentageBean::add_makeprofitbeanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean* _add = _internal_mutable_makeprofitbeanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.makeProfitBeanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>& StrategyAbovePercentageBean::makeprofitbeanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean.makeProfitBeanList)
  return _internal_makeprofitbeanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>&
StrategyAbovePercentageBean::_internal_makeprofitbeanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.makeprofitbeanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageMakeProfitBean>*
StrategyAbovePercentageBean::_internal_mutable_makeprofitbeanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.makeprofitbeanlist_;
}

// -------------------------------------------------------------------

// StrategyBean

// string symbol = 1;
inline void StrategyBean::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& StrategyBean::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StrategyBean::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.symbol)
}
inline std::string* StrategyBean::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyBean.symbol)
  return _s;
}
inline const std::string& StrategyBean::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void StrategyBean::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* StrategyBean::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* StrategyBean::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.StrategyBean.symbol)
  return _impl_.symbol_.Release();
}
inline void StrategyBean::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.StrategyBean.symbol)
}

// bool enabled = 2;
inline void StrategyBean::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool StrategyBean::enabled() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.enabled)
  return _internal_enabled();
}
inline void StrategyBean::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.enabled)
}
inline bool StrategyBean::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void StrategyBean::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// repeated string bannedSymbolList = 3;
inline int StrategyBean::_internal_bannedsymbollist_size() const {
  return _internal_bannedsymbollist().size();
}
inline int StrategyBean::bannedsymbollist_size() const {
  return _internal_bannedsymbollist_size();
}
inline void StrategyBean::clear_bannedsymbollist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bannedsymbollist_.Clear();
}
inline std::string* StrategyBean::add_bannedsymbollist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_bannedsymbollist()->Add();
  // @@protoc_insertion_point(field_add_mutable:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
  return _s;
}
inline const std::string& StrategyBean::bannedsymbollist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
  return _internal_bannedsymbollist().Get(index);
}
inline std::string* StrategyBean::mutable_bannedsymbollist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
  return _internal_mutable_bannedsymbollist()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StrategyBean::set_bannedsymbollist(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_bannedsymbollist()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
}
template <typename Arg_, typename... Args_>
inline void StrategyBean::add_bannedsymbollist(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_bannedsymbollist(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StrategyBean::bannedsymbollist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
  return _internal_bannedsymbollist();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StrategyBean::mutable_bannedsymbollist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.strategy.StrategyBean.bannedSymbolList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bannedsymbollist();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StrategyBean::_internal_bannedsymbollist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bannedsymbollist_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StrategyBean::_internal_mutable_bannedsymbollist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bannedsymbollist_;
}

// optional int32 strategyUID = 4;
inline bool StrategyBean::has_strategyuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StrategyBean::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t StrategyBean::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.strategyUID)
  return _internal_strategyuid();
}
inline void StrategyBean::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.strategyUID)
}
inline ::int32_t StrategyBean::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void StrategyBean::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// string timeInForceParam = 5;
inline void StrategyBean::clear_timeinforceparam() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeinforceparam_.ClearToEmpty();
}
inline const std::string& StrategyBean::timeinforceparam() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.timeInForceParam)
  return _internal_timeinforceparam();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StrategyBean::set_timeinforceparam(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeinforceparam_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.timeInForceParam)
}
inline std::string* StrategyBean::mutable_timeinforceparam() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timeinforceparam();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyBean.timeInForceParam)
  return _s;
}
inline const std::string& StrategyBean::_internal_timeinforceparam() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeinforceparam_.Get();
}
inline void StrategyBean::_internal_set_timeinforceparam(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeinforceparam_.Set(value, GetArena());
}
inline std::string* StrategyBean::_internal_mutable_timeinforceparam() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timeinforceparam_.Mutable( GetArena());
}
inline std::string* StrategyBean::release_timeinforceparam() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.StrategyBean.timeInForceParam)
  return _impl_.timeinforceparam_.Release();
}
inline void StrategyBean::set_allocated_timeinforceparam(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeinforceparam_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timeinforceparam_.IsDefault()) {
    _impl_.timeinforceparam_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.StrategyBean.timeInForceParam)
}

// int32 status = 6;
inline void StrategyBean::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::int32_t StrategyBean::status() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.status)
  return _internal_status();
}
inline void StrategyBean::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyBean.status)
}
inline ::int32_t StrategyBean::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_;
}
inline void StrategyBean::_internal_set_status(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .lampyris.crypto.protocol.strategy.StrategyAbovePercentageBean strategyAbovePercentageBean = 7;
inline bool StrategyBean::has_strategyabovepercentagebean() const {
  return ImplementBean_case() == kStrategyAbovePercentageBean;
}
inline bool StrategyBean::_internal_has_strategyabovepercentagebean() const {
  return ImplementBean_case() == kStrategyAbovePercentageBean;
}
inline void StrategyBean::set_has_strategyabovepercentagebean() {
  _impl_._oneof_case_[0] = kStrategyAbovePercentageBean;
}
inline void StrategyBean::clear_strategyabovepercentagebean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (ImplementBean_case() == kStrategyAbovePercentageBean) {
    if (GetArena() == nullptr) {
      delete _impl_.ImplementBean_.strategyabovepercentagebean_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.ImplementBean_.strategyabovepercentagebean_);
    }
    clear_has_ImplementBean();
  }
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* StrategyBean::release_strategyabovepercentagebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.StrategyBean.strategyAbovePercentageBean)
  if (ImplementBean_case() == kStrategyAbovePercentageBean) {
    clear_has_ImplementBean();
    auto* temp = _impl_.ImplementBean_.strategyabovepercentagebean_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ImplementBean_.strategyabovepercentagebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean& StrategyBean::_internal_strategyabovepercentagebean() const {
  return ImplementBean_case() == kStrategyAbovePercentageBean ? *_impl_.ImplementBean_.strategyabovepercentagebean_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean&>(::lampyris::crypto::protocol::strategy::_StrategyAbovePercentageBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean& StrategyBean::strategyabovepercentagebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyBean.strategyAbovePercentageBean)
  return _internal_strategyabovepercentagebean();
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* StrategyBean::unsafe_arena_release_strategyabovepercentagebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.strategy.StrategyBean.strategyAbovePercentageBean)
  if (ImplementBean_case() == kStrategyAbovePercentageBean) {
    clear_has_ImplementBean();
    auto* temp = _impl_.ImplementBean_.strategyabovepercentagebean_;
    _impl_.ImplementBean_.strategyabovepercentagebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StrategyBean::unsafe_arena_set_allocated_strategyabovepercentagebean(::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ImplementBean();
  if (value) {
    set_has_strategyabovepercentagebean();
    _impl_.ImplementBean_.strategyabovepercentagebean_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.strategy.StrategyBean.strategyAbovePercentageBean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* StrategyBean::_internal_mutable_strategyabovepercentagebean() {
  if (ImplementBean_case() != kStrategyAbovePercentageBean) {
    clear_ImplementBean();
    set_has_strategyabovepercentagebean();
    _impl_.ImplementBean_.strategyabovepercentagebean_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean>(GetArena());
  }
  return _impl_.ImplementBean_.strategyabovepercentagebean_;
}
inline ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* StrategyBean::mutable_strategyabovepercentagebean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StrategyAbovePercentageBean* _msg = _internal_mutable_strategyabovepercentagebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyBean.strategyAbovePercentageBean)
  return _msg;
}

inline bool StrategyBean::has_ImplementBean() const {
  return ImplementBean_case() != IMPLEMENTBEAN_NOT_SET;
}
inline void StrategyBean::clear_has_ImplementBean() {
  _impl_._oneof_case_[0] = IMPLEMENTBEAN_NOT_SET;
}
inline StrategyBean::ImplementBeanCase StrategyBean::ImplementBean_case() const {
  return StrategyBean::ImplementBeanCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReqStrategyAdd

// .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
inline bool ReqStrategyAdd::has_bean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bean_ != nullptr);
  return value;
}
inline void ReqStrategyAdd::clear_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ != nullptr) _impl_.bean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ReqStrategyAdd::_internal_bean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::strategy::StrategyBean* p = _impl_.bean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::strategy::StrategyBean&>(::lampyris::crypto::protocol::strategy::_StrategyBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ReqStrategyAdd::bean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyAdd.bean)
  return _internal_bean();
}
inline void ReqStrategyAdd::unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bean_);
  }
  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyAdd.bean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyAdd::release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* released = _impl_.bean_;
  _impl_.bean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyAdd::unsafe_arena_release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ReqStrategyAdd.bean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* temp = _impl_.bean_;
  _impl_.bean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyAdd::_internal_mutable_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyBean>(GetArena());
    _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(p);
  }
  return _impl_.bean_;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyAdd::mutable_bean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _msg = _internal_mutable_bean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ReqStrategyAdd.bean)
  return _msg;
}
inline void ReqStrategyAdd::set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.bean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyAdd.bean)
}

// -------------------------------------------------------------------

// ReqStrategyRemove

// int32 strategyUId = 1;
inline void ReqStrategyRemove::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
}
inline ::int32_t ReqStrategyRemove::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyRemove.strategyUId)
  return _internal_strategyuid();
}
inline void ReqStrategyRemove::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyRemove.strategyUId)
}
inline ::int32_t ReqStrategyRemove::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void ReqStrategyRemove::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// -------------------------------------------------------------------

// ReqStrategyAbort

// int32 strategyUId = 1;
inline void ReqStrategyAbort::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
}
inline ::int32_t ReqStrategyAbort::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyAbort.strategyUId)
  return _internal_strategyuid();
}
inline void ReqStrategyAbort::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyAbort.strategyUId)
}
inline ::int32_t ReqStrategyAbort::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void ReqStrategyAbort::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// string param = 2;
inline void ReqStrategyAbort::clear_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.param_.ClearToEmpty();
}
inline const std::string& ReqStrategyAbort::param() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyAbort.param)
  return _internal_param();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqStrategyAbort::set_param(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.param_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyAbort.param)
}
inline std::string* ReqStrategyAbort::mutable_param() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ReqStrategyAbort.param)
  return _s;
}
inline const std::string& ReqStrategyAbort::_internal_param() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.param_.Get();
}
inline void ReqStrategyAbort::_internal_set_param(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.param_.Set(value, GetArena());
}
inline std::string* ReqStrategyAbort::_internal_mutable_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.param_.Mutable( GetArena());
}
inline std::string* ReqStrategyAbort::release_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ReqStrategyAbort.param)
  return _impl_.param_.Release();
}
inline void ReqStrategyAbort::set_allocated_param(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.param_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyAbort.param)
}

// -------------------------------------------------------------------

// ReqStrategyEnableStatus

// int32 strategyUId = 1;
inline void ReqStrategyEnableStatus::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
}
inline ::int32_t ReqStrategyEnableStatus::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus.strategyUId)
  return _internal_strategyuid();
}
inline void ReqStrategyEnableStatus::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus.strategyUId)
}
inline ::int32_t ReqStrategyEnableStatus::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void ReqStrategyEnableStatus::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// bool enabled = 2;
inline void ReqStrategyEnableStatus::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool ReqStrategyEnableStatus::enabled() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus.enabled)
  return _internal_enabled();
}
inline void ReqStrategyEnableStatus::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus.enabled)
}
inline bool ReqStrategyEnableStatus::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void ReqStrategyEnableStatus::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// ResStrategyEnableStatus

// int32 strategyUId = 1;
inline void ResStrategyEnableStatus::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
}
inline ::int32_t ResStrategyEnableStatus::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus.strategyUId)
  return _internal_strategyuid();
}
inline void ResStrategyEnableStatus::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus.strategyUId)
}
inline ::int32_t ResStrategyEnableStatus::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void ResStrategyEnableStatus::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// bool enabled = 2;
inline void ResStrategyEnableStatus::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool ResStrategyEnableStatus::enabled() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus.enabled)
  return _internal_enabled();
}
inline void ResStrategyEnableStatus::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ResStrategyEnableStatus.enabled)
}
inline bool ResStrategyEnableStatus::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void ResStrategyEnableStatus::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// ReqStrategyQuery

// string symbol = 1;
inline void ReqStrategyQuery::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqStrategyQuery::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyQuery.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqStrategyQuery::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyQuery.symbol)
}
inline std::string* ReqStrategyQuery::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ReqStrategyQuery.symbol)
  return _s;
}
inline const std::string& ReqStrategyQuery::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqStrategyQuery::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqStrategyQuery::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqStrategyQuery::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ReqStrategyQuery.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqStrategyQuery::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyQuery.symbol)
}

// -------------------------------------------------------------------

// ResStrategyList

// repeated .lampyris.crypto.protocol.strategy.StrategyBean beanList = 1;
inline int ResStrategyList::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResStrategyList::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResStrategyList::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyList::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ResStrategyList.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>* ResStrategyList::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.strategy.ResStrategyList.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ResStrategyList::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyList.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyList::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::strategy::StrategyBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.strategy.ResStrategyList.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>& ResStrategyList::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.strategy.ResStrategyList.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>&
ResStrategyList::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyBean>*
ResStrategyList::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// ReqStrategyUpgrade

// .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
inline bool ReqStrategyUpgrade::has_bean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bean_ != nullptr);
  return value;
}
inline void ReqStrategyUpgrade::clear_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ != nullptr) _impl_.bean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ReqStrategyUpgrade::_internal_bean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::strategy::StrategyBean* p = _impl_.bean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::strategy::StrategyBean&>(::lampyris::crypto::protocol::strategy::_StrategyBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ReqStrategyUpgrade::bean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade.bean)
  return _internal_bean();
}
inline void ReqStrategyUpgrade::unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bean_);
  }
  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade.bean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyUpgrade::release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* released = _impl_.bean_;
  _impl_.bean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyUpgrade::unsafe_arena_release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade.bean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* temp = _impl_.bean_;
  _impl_.bean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyUpgrade::_internal_mutable_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyBean>(GetArena());
    _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(p);
  }
  return _impl_.bean_;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ReqStrategyUpgrade::mutable_bean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _msg = _internal_mutable_bean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade.bean)
  return _msg;
}
inline void ReqStrategyUpgrade::set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.bean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyUpgrade.bean)
}

// -------------------------------------------------------------------

// ResStrategyUpgrade

// .lampyris.crypto.protocol.strategy.StrategyBean bean = 1;
inline bool ResStrategyUpgrade::has_bean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bean_ != nullptr);
  return value;
}
inline void ResStrategyUpgrade::clear_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ != nullptr) _impl_.bean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ResStrategyUpgrade::_internal_bean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::strategy::StrategyBean* p = _impl_.bean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::strategy::StrategyBean&>(::lampyris::crypto::protocol::strategy::_StrategyBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyBean& ResStrategyUpgrade::bean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyUpgrade.bean)
  return _internal_bean();
}
inline void ResStrategyUpgrade::unsafe_arena_set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bean_);
  }
  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.strategy.ResStrategyUpgrade.bean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyUpgrade::release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* released = _impl_.bean_;
  _impl_.bean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyUpgrade::unsafe_arena_release_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ResStrategyUpgrade.bean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* temp = _impl_.bean_;
  _impl_.bean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyUpgrade::_internal_mutable_bean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyBean>(GetArena());
    _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(p);
  }
  return _impl_.bean_;
}
inline ::lampyris::crypto::protocol::strategy::StrategyBean* ResStrategyUpgrade::mutable_bean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::strategy::StrategyBean* _msg = _internal_mutable_bean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ResStrategyUpgrade.bean)
  return _msg;
}
inline void ResStrategyUpgrade::set_allocated_bean(::lampyris::crypto::protocol::strategy::StrategyBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.bean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bean_ = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ResStrategyUpgrade.bean)
}

// -------------------------------------------------------------------

// ReqStrategyExecutionHistory

// string symbol = 1;
inline void ReqStrategyExecutionHistory::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqStrategyExecutionHistory::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqStrategyExecutionHistory::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory.symbol)
}
inline std::string* ReqStrategyExecutionHistory::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory.symbol)
  return _s;
}
inline const std::string& ReqStrategyExecutionHistory::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqStrategyExecutionHistory::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqStrategyExecutionHistory::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqStrategyExecutionHistory::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqStrategyExecutionHistory::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory.symbol)
}

// -------------------------------------------------------------------

// StrategyExecutionHistoryBean

// string symbol = 1;
inline void StrategyExecutionHistoryBean::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& StrategyExecutionHistoryBean::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StrategyExecutionHistoryBean::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.symbol)
}
inline std::string* StrategyExecutionHistoryBean::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.symbol)
  return _s;
}
inline const std::string& StrategyExecutionHistoryBean::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void StrategyExecutionHistoryBean::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* StrategyExecutionHistoryBean::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* StrategyExecutionHistoryBean::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.symbol)
  return _impl_.symbol_.Release();
}
inline void StrategyExecutionHistoryBean::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.symbol)
}

// int64 triggeredTime = 2;
inline void StrategyExecutionHistoryBean::clear_triggeredtime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggeredtime_ = ::int64_t{0};
}
inline ::int64_t StrategyExecutionHistoryBean::triggeredtime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.triggeredTime)
  return _internal_triggeredtime();
}
inline void StrategyExecutionHistoryBean::set_triggeredtime(::int64_t value) {
  _internal_set_triggeredtime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.triggeredTime)
}
inline ::int64_t StrategyExecutionHistoryBean::_internal_triggeredtime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triggeredtime_;
}
inline void StrategyExecutionHistoryBean::_internal_set_triggeredtime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggeredtime_ = value;
}

// string lastAction = 3;
inline void StrategyExecutionHistoryBean::clear_lastaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastaction_.ClearToEmpty();
}
inline const std::string& StrategyExecutionHistoryBean::lastaction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastAction)
  return _internal_lastaction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StrategyExecutionHistoryBean::set_lastaction(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastaction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastAction)
}
inline std::string* StrategyExecutionHistoryBean::mutable_lastaction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lastaction();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastAction)
  return _s;
}
inline const std::string& StrategyExecutionHistoryBean::_internal_lastaction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lastaction_.Get();
}
inline void StrategyExecutionHistoryBean::_internal_set_lastaction(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastaction_.Set(value, GetArena());
}
inline std::string* StrategyExecutionHistoryBean::_internal_mutable_lastaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.lastaction_.Mutable( GetArena());
}
inline std::string* StrategyExecutionHistoryBean::release_lastaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastAction)
  return _impl_.lastaction_.Release();
}
inline void StrategyExecutionHistoryBean::set_allocated_lastaction(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastaction_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.lastaction_.IsDefault()) {
    _impl_.lastaction_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastAction)
}

// int64 lastActionTime = 4;
inline void StrategyExecutionHistoryBean::clear_lastactiontime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastactiontime_ = ::int64_t{0};
}
inline ::int64_t StrategyExecutionHistoryBean::lastactiontime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastActionTime)
  return _internal_lastactiontime();
}
inline void StrategyExecutionHistoryBean::set_lastactiontime(::int64_t value) {
  _internal_set_lastactiontime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean.lastActionTime)
}
inline ::int64_t StrategyExecutionHistoryBean::_internal_lastactiontime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lastactiontime_;
}
inline void StrategyExecutionHistoryBean::_internal_set_lastactiontime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lastactiontime_ = value;
}

// -------------------------------------------------------------------

// ResStrategyExecutionHistory

// repeated .lampyris.crypto.protocol.strategy.StrategyExecutionHistoryBean beanList = 1;
inline int ResStrategyExecutionHistory::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResStrategyExecutionHistory::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResStrategyExecutionHistory::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean* ResStrategyExecutionHistory::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>* ResStrategyExecutionHistory::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean& ResStrategyExecutionHistory::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean* ResStrategyExecutionHistory::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>& ResStrategyExecutionHistory::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>&
ResStrategyExecutionHistory::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::strategy::StrategyExecutionHistoryBean>*
ResStrategyExecutionHistory::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// ReqStrategyExecutionLog

// int32 strategyUId = 1;
inline void ReqStrategyExecutionLog::clear_strategyuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = 0;
}
inline ::int32_t ReqStrategyExecutionLog::strategyuid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog.strategyUId)
  return _internal_strategyuid();
}
inline void ReqStrategyExecutionLog::set_strategyuid(::int32_t value) {
  _internal_set_strategyuid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog.strategyUId)
}
inline ::int32_t ReqStrategyExecutionLog::_internal_strategyuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strategyuid_;
}
inline void ReqStrategyExecutionLog::_internal_set_strategyuid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strategyuid_ = value;
}

// -------------------------------------------------------------------

// ResStrategyExecutionLog

// repeated string logList = 1;
inline int ResStrategyExecutionLog::_internal_loglist_size() const {
  return _internal_loglist().size();
}
inline int ResStrategyExecutionLog::loglist_size() const {
  return _internal_loglist_size();
}
inline void ResStrategyExecutionLog::clear_loglist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.loglist_.Clear();
}
inline std::string* ResStrategyExecutionLog::add_loglist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_loglist()->Add();
  // @@protoc_insertion_point(field_add_mutable:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
  return _s;
}
inline const std::string& ResStrategyExecutionLog::loglist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
  return _internal_loglist().Get(index);
}
inline std::string* ResStrategyExecutionLog::mutable_loglist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
  return _internal_mutable_loglist()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ResStrategyExecutionLog::set_loglist(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_loglist()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
}
template <typename Arg_, typename... Args_>
inline void ResStrategyExecutionLog::add_loglist(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_loglist(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResStrategyExecutionLog::loglist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
  return _internal_loglist();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResStrategyExecutionLog::mutable_loglist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.logList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_loglist();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResStrategyExecutionLog::_internal_loglist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.loglist_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResStrategyExecutionLog::_internal_mutable_loglist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.loglist_;
}

// bool isIncrement = 2;
inline void ResStrategyExecutionLog::clear_isincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isincrement_ = false;
}
inline bool ResStrategyExecutionLog::isincrement() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.isIncrement)
  return _internal_isincrement();
}
inline void ResStrategyExecutionLog::set_isincrement(bool value) {
  _internal_set_isincrement(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.strategy.ResStrategyExecutionLog.isIncrement)
}
inline bool ResStrategyExecutionLog::_internal_isincrement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.isincrement_;
}
inline void ResStrategyExecutionLog::_internal_set_isincrement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isincrement_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace strategy
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // strategy_2eproto_2epb_2eh
