// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 5.29.3

#ifndef common_2eproto_2epb_2eh
#define common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "quote.h"
#include "trading.h"
#include "app.h"
#include "strategy.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2eproto;
namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class Response final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Response* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Response));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response(
      ::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from) : Response(nullptr, from) {}
  inline Response(Response&& from) noexcept
      : Response(nullptr, std::move(from)) {}
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kResSubscribeTickerData = 1,
    kResCandlestickQuery = 2,
    kResTradeRule = 3,
    kResSelfSelectedSymbol = 4,
    kResMarketPreviewData = 5,
    kResQueryOrders = 6,
    kResQueryPositions = 7,
    kResQueryLeverage = 8,
    kResQueryLeverageBracket = 9,
    kResHeartBeat = 10,
    kResClientMessage = 11,
    kResServerLogQuery = 12,
    kResServerLogPush = 13,
    kResStrategyEnableStatus = 14,
    kResStrategyList = 15,
    kResStrategyUpgrade = 16,
    kResStrategyExecutionHistory = 17,
    kResStrategyExecutionLog = 18,
    RESPONSE_TYPE_NOT_SET = 0,
  };
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
        &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Response& a, Response& b) { a.Swap(&b); }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Response& from) { Response::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Response* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Response"; }

 protected:
  explicit Response(::google::protobuf::Arena* arena);
  Response(::google::protobuf::Arena* arena, const Response& from);
  Response(::google::protobuf::Arena* arena, Response&& from) noexcept
      : Response(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResSubscribeTickerDataFieldNumber = 1,
    kResCandlestickQueryFieldNumber = 2,
    kResTradeRuleFieldNumber = 3,
    kResSelfSelectedSymbolFieldNumber = 4,
    kResMarketPreviewDataFieldNumber = 5,
    kResQueryOrdersFieldNumber = 6,
    kResQueryPositionsFieldNumber = 7,
    kResQueryLeverageFieldNumber = 8,
    kResQueryLeverageBracketFieldNumber = 9,
    kResHeartBeatFieldNumber = 10,
    kResClientMessageFieldNumber = 11,
    kResServerLogQueryFieldNumber = 12,
    kResServerLogPushFieldNumber = 13,
    kResStrategyEnableStatusFieldNumber = 14,
    kResStrategyListFieldNumber = 15,
    kResStrategyUpgradeFieldNumber = 16,
    kResStrategyExecutionHistoryFieldNumber = 17,
    kResStrategyExecutionLogFieldNumber = 18,
  };
  // .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 1;
  bool has_ressubscribetickerdata() const;
  private:
  bool _internal_has_ressubscribetickerdata() const;

  public:
  void clear_ressubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& ressubscribetickerdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* release_ressubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* mutable_ressubscribetickerdata();
  void set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value);
  void unsafe_arena_set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value);
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* unsafe_arena_release_ressubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& _internal_ressubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* _internal_mutable_ressubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 2;
  bool has_rescandlestickquery() const;
  private:
  bool _internal_has_rescandlestickquery() const;

  public:
  void clear_rescandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& rescandlestickquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResCandlestickQuery* release_rescandlestickquery();
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* mutable_rescandlestickquery();
  void set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value);
  void unsafe_arena_set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value);
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* unsafe_arena_release_rescandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& _internal_rescandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* _internal_mutable_rescandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 3;
  bool has_restraderule() const;
  private:
  bool _internal_has_restraderule() const;

  public:
  void clear_restraderule() ;
  const ::lampyris::crypto::protocol::quote::ResTradeRule& restraderule() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResTradeRule* release_restraderule();
  ::lampyris::crypto::protocol::quote::ResTradeRule* mutable_restraderule();
  void set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value);
  void unsafe_arena_set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value);
  ::lampyris::crypto::protocol::quote::ResTradeRule* unsafe_arena_release_restraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ResTradeRule& _internal_restraderule() const;
  ::lampyris::crypto::protocol::quote::ResTradeRule* _internal_mutable_restraderule();

  public:
  // .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 4;
  bool has_resselfselectedsymbol() const;
  private:
  bool _internal_has_resselfselectedsymbol() const;

  public:
  void clear_resselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& resselfselectedsymbol() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* release_resselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* mutable_resselfselectedsymbol();
  void set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value);
  void unsafe_arena_set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value);
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* unsafe_arena_release_resselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& _internal_resselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* _internal_mutable_resselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 5;
  bool has_resmarketpreviewdata() const;
  private:
  bool _internal_has_resmarketpreviewdata() const;

  public:
  void clear_resmarketpreviewdata() ;
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& resmarketpreviewdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ResMarketPreviewData* release_resmarketpreviewdata();
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* mutable_resmarketpreviewdata();
  void set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value);
  void unsafe_arena_set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value);
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* unsafe_arena_release_resmarketpreviewdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& _internal_resmarketpreviewdata() const;
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* _internal_mutable_resmarketpreviewdata();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 6;
  bool has_resqueryorders() const;
  private:
  bool _internal_has_resqueryorders() const;

  public:
  void clear_resqueryorders() ;
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& resqueryorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryOrders* release_resqueryorders();
  ::lampyris::crypto::protocol::trading::ResQueryOrders* mutable_resqueryorders();
  void set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value);
  void unsafe_arena_set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value);
  ::lampyris::crypto::protocol::trading::ResQueryOrders* unsafe_arena_release_resqueryorders();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& _internal_resqueryorders() const;
  ::lampyris::crypto::protocol::trading::ResQueryOrders* _internal_mutable_resqueryorders();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 7;
  bool has_resquerypositions() const;
  private:
  bool _internal_has_resquerypositions() const;

  public:
  void clear_resquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& resquerypositions() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryPositions* release_resquerypositions();
  ::lampyris::crypto::protocol::trading::ResQueryPositions* mutable_resquerypositions();
  void set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value);
  void unsafe_arena_set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value);
  ::lampyris::crypto::protocol::trading::ResQueryPositions* unsafe_arena_release_resquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& _internal_resquerypositions() const;
  ::lampyris::crypto::protocol::trading::ResQueryPositions* _internal_mutable_resquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 8;
  bool has_resqueryleverage() const;
  private:
  bool _internal_has_resqueryleverage() const;

  public:
  void clear_resqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& resqueryleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryLeverage* release_resqueryleverage();
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* mutable_resqueryleverage();
  void set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value);
  void unsafe_arena_set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* unsafe_arena_release_resqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& _internal_resqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* _internal_mutable_resqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 9;
  bool has_resqueryleveragebracket() const;
  private:
  bool _internal_has_resqueryleveragebracket() const;

  public:
  void clear_resqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& resqueryleveragebracket() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* release_resqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* mutable_resqueryleveragebracket();
  void set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value);
  void unsafe_arena_set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* unsafe_arena_release_resqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& _internal_resqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* _internal_mutable_resqueryleveragebracket();

  public:
  // .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 10;
  bool has_resheartbeat() const;
  private:
  bool _internal_has_resheartbeat() const;

  public:
  void clear_resheartbeat() ;
  const ::lampyris::crypto::protocol::app::ResHeartBeat& resheartbeat() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResHeartBeat* release_resheartbeat();
  ::lampyris::crypto::protocol::app::ResHeartBeat* mutable_resheartbeat();
  void set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value);
  void unsafe_arena_set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value);
  ::lampyris::crypto::protocol::app::ResHeartBeat* unsafe_arena_release_resheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ResHeartBeat& _internal_resheartbeat() const;
  ::lampyris::crypto::protocol::app::ResHeartBeat* _internal_mutable_resheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ResClientMessage resClientMessage = 11;
  bool has_resclientmessage() const;
  private:
  bool _internal_has_resclientmessage() const;

  public:
  void clear_resclientmessage() ;
  const ::lampyris::crypto::protocol::app::ResClientMessage& resclientmessage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResClientMessage* release_resclientmessage();
  ::lampyris::crypto::protocol::app::ResClientMessage* mutable_resclientmessage();
  void set_allocated_resclientmessage(::lampyris::crypto::protocol::app::ResClientMessage* value);
  void unsafe_arena_set_allocated_resclientmessage(::lampyris::crypto::protocol::app::ResClientMessage* value);
  ::lampyris::crypto::protocol::app::ResClientMessage* unsafe_arena_release_resclientmessage();

  private:
  const ::lampyris::crypto::protocol::app::ResClientMessage& _internal_resclientmessage() const;
  ::lampyris::crypto::protocol::app::ResClientMessage* _internal_mutable_resclientmessage();

  public:
  // .lampyris.crypto.protocol.app.ResServerLogQuery resServerLogQuery = 12;
  bool has_resserverlogquery() const;
  private:
  bool _internal_has_resserverlogquery() const;

  public:
  void clear_resserverlogquery() ;
  const ::lampyris::crypto::protocol::app::ResServerLogQuery& resserverlogquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResServerLogQuery* release_resserverlogquery();
  ::lampyris::crypto::protocol::app::ResServerLogQuery* mutable_resserverlogquery();
  void set_allocated_resserverlogquery(::lampyris::crypto::protocol::app::ResServerLogQuery* value);
  void unsafe_arena_set_allocated_resserverlogquery(::lampyris::crypto::protocol::app::ResServerLogQuery* value);
  ::lampyris::crypto::protocol::app::ResServerLogQuery* unsafe_arena_release_resserverlogquery();

  private:
  const ::lampyris::crypto::protocol::app::ResServerLogQuery& _internal_resserverlogquery() const;
  ::lampyris::crypto::protocol::app::ResServerLogQuery* _internal_mutable_resserverlogquery();

  public:
  // .lampyris.crypto.protocol.app.ResServerLogPush resServerLogPush = 13;
  bool has_resserverlogpush() const;
  private:
  bool _internal_has_resserverlogpush() const;

  public:
  void clear_resserverlogpush() ;
  const ::lampyris::crypto::protocol::app::ResServerLogPush& resserverlogpush() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ResServerLogPush* release_resserverlogpush();
  ::lampyris::crypto::protocol::app::ResServerLogPush* mutable_resserverlogpush();
  void set_allocated_resserverlogpush(::lampyris::crypto::protocol::app::ResServerLogPush* value);
  void unsafe_arena_set_allocated_resserverlogpush(::lampyris::crypto::protocol::app::ResServerLogPush* value);
  ::lampyris::crypto::protocol::app::ResServerLogPush* unsafe_arena_release_resserverlogpush();

  private:
  const ::lampyris::crypto::protocol::app::ResServerLogPush& _internal_resserverlogpush() const;
  ::lampyris::crypto::protocol::app::ResServerLogPush* _internal_mutable_resserverlogpush();

  public:
  // .lampyris.crypto.protocol.strategy.ResStrategyEnableStatus resStrategyEnableStatus = 14;
  bool has_resstrategyenablestatus() const;
  private:
  bool _internal_has_resstrategyenablestatus() const;

  public:
  void clear_resstrategyenablestatus() ;
  const ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus& resstrategyenablestatus() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* release_resstrategyenablestatus();
  ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* mutable_resstrategyenablestatus();
  void set_allocated_resstrategyenablestatus(::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* value);
  void unsafe_arena_set_allocated_resstrategyenablestatus(::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* value);
  ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* unsafe_arena_release_resstrategyenablestatus();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus& _internal_resstrategyenablestatus() const;
  ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* _internal_mutable_resstrategyenablestatus();

  public:
  // .lampyris.crypto.protocol.strategy.ResStrategyList resStrategyList = 15;
  bool has_resstrategylist() const;
  private:
  bool _internal_has_resstrategylist() const;

  public:
  void clear_resstrategylist() ;
  const ::lampyris::crypto::protocol::strategy::ResStrategyList& resstrategylist() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStrategyList* release_resstrategylist();
  ::lampyris::crypto::protocol::strategy::ResStrategyList* mutable_resstrategylist();
  void set_allocated_resstrategylist(::lampyris::crypto::protocol::strategy::ResStrategyList* value);
  void unsafe_arena_set_allocated_resstrategylist(::lampyris::crypto::protocol::strategy::ResStrategyList* value);
  ::lampyris::crypto::protocol::strategy::ResStrategyList* unsafe_arena_release_resstrategylist();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStrategyList& _internal_resstrategylist() const;
  ::lampyris::crypto::protocol::strategy::ResStrategyList* _internal_mutable_resstrategylist();

  public:
  // .lampyris.crypto.protocol.strategy.ResStrategyUpgrade resStrategyUpgrade = 16;
  bool has_resstrategyupgrade() const;
  private:
  bool _internal_has_resstrategyupgrade() const;

  public:
  void clear_resstrategyupgrade() ;
  const ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade& resstrategyupgrade() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* release_resstrategyupgrade();
  ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* mutable_resstrategyupgrade();
  void set_allocated_resstrategyupgrade(::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* value);
  void unsafe_arena_set_allocated_resstrategyupgrade(::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* value);
  ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* unsafe_arena_release_resstrategyupgrade();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade& _internal_resstrategyupgrade() const;
  ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* _internal_mutable_resstrategyupgrade();

  public:
  // .lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory resStrategyExecutionHistory = 17;
  bool has_resstrategyexecutionhistory() const;
  private:
  bool _internal_has_resstrategyexecutionhistory() const;

  public:
  void clear_resstrategyexecutionhistory() ;
  const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory& resstrategyexecutionhistory() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* release_resstrategyexecutionhistory();
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* mutable_resstrategyexecutionhistory();
  void set_allocated_resstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* value);
  void unsafe_arena_set_allocated_resstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* value);
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* unsafe_arena_release_resstrategyexecutionhistory();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory& _internal_resstrategyexecutionhistory() const;
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* _internal_mutable_resstrategyexecutionhistory();

  public:
  // .lampyris.crypto.protocol.strategy.ResStrategyExecutionLog resStrategyExecutionLog = 18;
  bool has_resstrategyexecutionlog() const;
  private:
  bool _internal_has_resstrategyexecutionlog() const;

  public:
  void clear_resstrategyexecutionlog() ;
  const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog& resstrategyexecutionlog() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* release_resstrategyexecutionlog();
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* mutable_resstrategyexecutionlog();
  void set_allocated_resstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* value);
  void unsafe_arena_set_allocated_resstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* value);
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* unsafe_arena_release_resstrategyexecutionlog();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog& _internal_resstrategyexecutionlog() const;
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* _internal_mutable_resstrategyexecutionlog();

  public:
  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Response)
 private:
  class _Internal;
  void set_has_ressubscribetickerdata();
  void set_has_rescandlestickquery();
  void set_has_restraderule();
  void set_has_resselfselectedsymbol();
  void set_has_resmarketpreviewdata();
  void set_has_resqueryorders();
  void set_has_resquerypositions();
  void set_has_resqueryleverage();
  void set_has_resqueryleveragebracket();
  void set_has_resheartbeat();
  void set_has_resclientmessage();
  void set_has_resserverlogquery();
  void set_has_resserverlogpush();
  void set_has_resstrategyenablestatus();
  void set_has_resstrategylist();
  void set_has_resstrategyupgrade();
  void set_has_resstrategyexecutionhistory();
  void set_has_resstrategyexecutionlog();
  inline bool has_response_type() const;
  inline void clear_has_response_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 18, 18,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Response& from_msg);
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* ressubscribetickerdata_;
      ::lampyris::crypto::protocol::quote::ResCandlestickQuery* rescandlestickquery_;
      ::lampyris::crypto::protocol::quote::ResTradeRule* restraderule_;
      ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* resselfselectedsymbol_;
      ::lampyris::crypto::protocol::quote::ResMarketPreviewData* resmarketpreviewdata_;
      ::lampyris::crypto::protocol::trading::ResQueryOrders* resqueryorders_;
      ::lampyris::crypto::protocol::trading::ResQueryPositions* resquerypositions_;
      ::lampyris::crypto::protocol::trading::ResQueryLeverage* resqueryleverage_;
      ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* resqueryleveragebracket_;
      ::lampyris::crypto::protocol::app::ResHeartBeat* resheartbeat_;
      ::lampyris::crypto::protocol::app::ResClientMessage* resclientmessage_;
      ::lampyris::crypto::protocol::app::ResServerLogQuery* resserverlogquery_;
      ::lampyris::crypto::protocol::app::ResServerLogPush* resserverlogpush_;
      ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* resstrategyenablestatus_;
      ::lampyris::crypto::protocol::strategy::ResStrategyList* resstrategylist_;
      ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* resstrategyupgrade_;
      ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* resstrategyexecutionhistory_;
      ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* resstrategyexecutionlog_;
    } response_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Request final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Request* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Request));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Request(
      ::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from) : Request(nullptr, from) {}
  inline Request(Request&& from) noexcept
      : Request(nullptr, std::move(from)) {}
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kReqSubscribeTickerData = 1,
    kReqSubscribeTradeData = 2,
    kReqSubscribeCandlestickUpdate = 3,
    kReqCandlestickQuery = 4,
    kReqTradeRule = 5,
    kReqSelfSelectedSymbol = 6,
    kReqPlaceOrder = 7,
    kReqModifyOrder = 8,
    kReqCancelOrder = 9,
    kReqOneKeyClosePosition = 10,
    kReqQueryActiveOrders = 11,
    kReqQueryHistoricalOrders = 12,
    kReqQueryPositions = 13,
    kReqSetLeverage = 14,
    kReqQueryLeverage = 15,
    kReqQueryLeverageBracket = 16,
    kReqHeartBeat = 17,
    kReqServerLogQuery = 18,
    kReqStrategyAdd = 19,
    kReqStrategyRemove = 20,
    kReqStrategyAbort = 21,
    kReqStrategyEnableStatus = 22,
    kReqStrategyQuery = 23,
    kReqStrategyUpgrade = 24,
    kReqStrategyExecutionHistory = 25,
    kReqStrategyExecutionLog = 26,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
        &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Request& a, Request& b) { a.Swap(&b); }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Request& from) { Request::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Request* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Request"; }

 protected:
  explicit Request(::google::protobuf::Arena* arena);
  Request(::google::protobuf::Arena* arena, const Request& from);
  Request(::google::protobuf::Arena* arena, Request&& from) noexcept
      : Request(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReqSubscribeTickerDataFieldNumber = 1,
    kReqSubscribeTradeDataFieldNumber = 2,
    kReqSubscribeCandlestickUpdateFieldNumber = 3,
    kReqCandlestickQueryFieldNumber = 4,
    kReqTradeRuleFieldNumber = 5,
    kReqSelfSelectedSymbolFieldNumber = 6,
    kReqPlaceOrderFieldNumber = 7,
    kReqModifyOrderFieldNumber = 8,
    kReqCancelOrderFieldNumber = 9,
    kReqOneKeyClosePositionFieldNumber = 10,
    kReqQueryActiveOrdersFieldNumber = 11,
    kReqQueryHistoricalOrdersFieldNumber = 12,
    kReqQueryPositionsFieldNumber = 13,
    kReqSetLeverageFieldNumber = 14,
    kReqQueryLeverageFieldNumber = 15,
    kReqQueryLeverageBracketFieldNumber = 16,
    kReqHeartBeatFieldNumber = 17,
    kReqServerLogQueryFieldNumber = 18,
    kReqStrategyAddFieldNumber = 19,
    kReqStrategyRemoveFieldNumber = 20,
    kReqStrategyAbortFieldNumber = 21,
    kReqStrategyEnableStatusFieldNumber = 22,
    kReqStrategyQueryFieldNumber = 23,
    kReqStrategyUpgradeFieldNumber = 24,
    kReqStrategyExecutionHistoryFieldNumber = 25,
    kReqStrategyExecutionLogFieldNumber = 26,
  };
  // .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 1;
  bool has_reqsubscribetickerdata() const;
  private:
  bool _internal_has_reqsubscribetickerdata() const;

  public:
  void clear_reqsubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& reqsubscribetickerdata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* release_reqsubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* mutable_reqsubscribetickerdata();
  void set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value);
  void unsafe_arena_set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* unsafe_arena_release_reqsubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& _internal_reqsubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* _internal_mutable_reqsubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 2;
  bool has_reqsubscribetradedata() const;
  private:
  bool _internal_has_reqsubscribetradedata() const;

  public:
  void clear_reqsubscribetradedata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& reqsubscribetradedata() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* release_reqsubscribetradedata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* mutable_reqsubscribetradedata();
  void set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value);
  void unsafe_arena_set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* unsafe_arena_release_reqsubscribetradedata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& _internal_reqsubscribetradedata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* _internal_mutable_reqsubscribetradedata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 3;
  bool has_reqsubscribecandlestickupdate() const;
  private:
  bool _internal_has_reqsubscribecandlestickupdate() const;

  public:
  void clear_reqsubscribecandlestickupdate() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& reqsubscribecandlestickupdate() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* release_reqsubscribecandlestickupdate();
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* mutable_reqsubscribecandlestickupdate();
  void set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value);
  void unsafe_arena_set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* unsafe_arena_release_reqsubscribecandlestickupdate();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& _internal_reqsubscribecandlestickupdate() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* _internal_mutable_reqsubscribecandlestickupdate();

  public:
  // .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 4;
  bool has_reqcandlestickquery() const;
  private:
  bool _internal_has_reqcandlestickquery() const;

  public:
  void clear_reqcandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& reqcandlestickquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* release_reqcandlestickquery();
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* mutable_reqcandlestickquery();
  void set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value);
  void unsafe_arena_set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value);
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* unsafe_arena_release_reqcandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& _internal_reqcandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* _internal_mutable_reqcandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 5;
  bool has_reqtraderule() const;
  private:
  bool _internal_has_reqtraderule() const;

  public:
  void clear_reqtraderule() ;
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& reqtraderule() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqTradeRule* release_reqtraderule();
  ::lampyris::crypto::protocol::quote::ReqTradeRule* mutable_reqtraderule();
  void set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value);
  void unsafe_arena_set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value);
  ::lampyris::crypto::protocol::quote::ReqTradeRule* unsafe_arena_release_reqtraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& _internal_reqtraderule() const;
  ::lampyris::crypto::protocol::quote::ReqTradeRule* _internal_mutable_reqtraderule();

  public:
  // .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 6;
  bool has_reqselfselectedsymbol() const;
  private:
  bool _internal_has_reqselfselectedsymbol() const;

  public:
  void clear_reqselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& reqselfselectedsymbol() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* release_reqselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* mutable_reqselfselectedsymbol();
  void set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value);
  void unsafe_arena_set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value);
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* unsafe_arena_release_reqselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& _internal_reqselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* _internal_mutable_reqselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 7;
  bool has_reqplaceorder() const;
  private:
  bool _internal_has_reqplaceorder() const;

  public:
  void clear_reqplaceorder() ;
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& reqplaceorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqPlaceOrder* release_reqplaceorder();
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* mutable_reqplaceorder();
  void set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value);
  void unsafe_arena_set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value);
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* unsafe_arena_release_reqplaceorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& _internal_reqplaceorder() const;
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* _internal_mutable_reqplaceorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 8;
  bool has_reqmodifyorder() const;
  private:
  bool _internal_has_reqmodifyorder() const;

  public:
  void clear_reqmodifyorder() ;
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& reqmodifyorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqModifyOrder* release_reqmodifyorder();
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* mutable_reqmodifyorder();
  void set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value);
  void unsafe_arena_set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value);
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* unsafe_arena_release_reqmodifyorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& _internal_reqmodifyorder() const;
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* _internal_mutable_reqmodifyorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 9;
  bool has_reqcancelorder() const;
  private:
  bool _internal_has_reqcancelorder() const;

  public:
  void clear_reqcancelorder() ;
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& reqcancelorder() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqCancelOrder* release_reqcancelorder();
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* mutable_reqcancelorder();
  void set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value);
  void unsafe_arena_set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value);
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* unsafe_arena_release_reqcancelorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& _internal_reqcancelorder() const;
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* _internal_mutable_reqcancelorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 10;
  bool has_reqonekeycloseposition() const;
  private:
  bool _internal_has_reqonekeycloseposition() const;

  public:
  void clear_reqonekeycloseposition() ;
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& reqonekeycloseposition() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* release_reqonekeycloseposition();
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* mutable_reqonekeycloseposition();
  void set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value);
  void unsafe_arena_set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value);
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* unsafe_arena_release_reqonekeycloseposition();

  private:
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& _internal_reqonekeycloseposition() const;
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* _internal_mutable_reqonekeycloseposition();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 11;
  bool has_reqqueryactiveorders() const;
  private:
  bool _internal_has_reqqueryactiveorders() const;

  public:
  void clear_reqqueryactiveorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& reqqueryactiveorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* release_reqqueryactiveorders();
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* mutable_reqqueryactiveorders();
  void set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value);
  void unsafe_arena_set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value);
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* unsafe_arena_release_reqqueryactiveorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& _internal_reqqueryactiveorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* _internal_mutable_reqqueryactiveorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 12;
  bool has_reqqueryhistoricalorders() const;
  private:
  bool _internal_has_reqqueryhistoricalorders() const;

  public:
  void clear_reqqueryhistoricalorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& reqqueryhistoricalorders() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* release_reqqueryhistoricalorders();
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* mutable_reqqueryhistoricalorders();
  void set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value);
  void unsafe_arena_set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value);
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* unsafe_arena_release_reqqueryhistoricalorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& _internal_reqqueryhistoricalorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* _internal_mutable_reqqueryhistoricalorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 13;
  bool has_reqquerypositions() const;
  private:
  bool _internal_has_reqquerypositions() const;

  public:
  void clear_reqquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& reqquerypositions() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryPositions* release_reqquerypositions();
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* mutable_reqquerypositions();
  void set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value);
  void unsafe_arena_set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value);
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* unsafe_arena_release_reqquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& _internal_reqquerypositions() const;
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* _internal_mutable_reqquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 14;
  bool has_reqsetleverage() const;
  private:
  bool _internal_has_reqsetleverage() const;

  public:
  void clear_reqsetleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& reqsetleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqSetLeverage* release_reqsetleverage();
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* mutable_reqsetleverage();
  void set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value);
  void unsafe_arena_set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value);
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* unsafe_arena_release_reqsetleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& _internal_reqsetleverage() const;
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* _internal_mutable_reqsetleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 15;
  bool has_reqqueryleverage() const;
  private:
  bool _internal_has_reqqueryleverage() const;

  public:
  void clear_reqqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& reqqueryleverage() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryLeverage* release_reqqueryleverage();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* mutable_reqqueryleverage();
  void set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value);
  void unsafe_arena_set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* unsafe_arena_release_reqqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& _internal_reqqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* _internal_mutable_reqqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 16;
  bool has_reqqueryleveragebracket() const;
  private:
  bool _internal_has_reqqueryleveragebracket() const;

  public:
  void clear_reqqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& reqqueryleveragebracket() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* release_reqqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* mutable_reqqueryleveragebracket();
  void set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value);
  void unsafe_arena_set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* unsafe_arena_release_reqqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& _internal_reqqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* _internal_mutable_reqqueryleveragebracket();

  public:
  // .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 17;
  bool has_reqheartbeat() const;
  private:
  bool _internal_has_reqheartbeat() const;

  public:
  void clear_reqheartbeat() ;
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& reqheartbeat() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqHeartBeat* release_reqheartbeat();
  ::lampyris::crypto::protocol::app::ReqHeartBeat* mutable_reqheartbeat();
  void set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value);
  void unsafe_arena_set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value);
  ::lampyris::crypto::protocol::app::ReqHeartBeat* unsafe_arena_release_reqheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& _internal_reqheartbeat() const;
  ::lampyris::crypto::protocol::app::ReqHeartBeat* _internal_mutable_reqheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ReqServerLogQuery reqServerLogQuery = 18;
  bool has_reqserverlogquery() const;
  private:
  bool _internal_has_reqserverlogquery() const;

  public:
  void clear_reqserverlogquery() ;
  const ::lampyris::crypto::protocol::app::ReqServerLogQuery& reqserverlogquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::app::ReqServerLogQuery* release_reqserverlogquery();
  ::lampyris::crypto::protocol::app::ReqServerLogQuery* mutable_reqserverlogquery();
  void set_allocated_reqserverlogquery(::lampyris::crypto::protocol::app::ReqServerLogQuery* value);
  void unsafe_arena_set_allocated_reqserverlogquery(::lampyris::crypto::protocol::app::ReqServerLogQuery* value);
  ::lampyris::crypto::protocol::app::ReqServerLogQuery* unsafe_arena_release_reqserverlogquery();

  private:
  const ::lampyris::crypto::protocol::app::ReqServerLogQuery& _internal_reqserverlogquery() const;
  ::lampyris::crypto::protocol::app::ReqServerLogQuery* _internal_mutable_reqserverlogquery();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyAdd reqStrategyAdd = 19;
  bool has_reqstrategyadd() const;
  private:
  bool _internal_has_reqstrategyadd() const;

  public:
  void clear_reqstrategyadd() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyAdd& reqstrategyadd() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* release_reqstrategyadd();
  ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* mutable_reqstrategyadd();
  void set_allocated_reqstrategyadd(::lampyris::crypto::protocol::strategy::ReqStrategyAdd* value);
  void unsafe_arena_set_allocated_reqstrategyadd(::lampyris::crypto::protocol::strategy::ReqStrategyAdd* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* unsafe_arena_release_reqstrategyadd();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyAdd& _internal_reqstrategyadd() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* _internal_mutable_reqstrategyadd();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyRemove reqStrategyRemove = 20;
  bool has_reqstrategyremove() const;
  private:
  bool _internal_has_reqstrategyremove() const;

  public:
  void clear_reqstrategyremove() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyRemove& reqstrategyremove() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* release_reqstrategyremove();
  ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* mutable_reqstrategyremove();
  void set_allocated_reqstrategyremove(::lampyris::crypto::protocol::strategy::ReqStrategyRemove* value);
  void unsafe_arena_set_allocated_reqstrategyremove(::lampyris::crypto::protocol::strategy::ReqStrategyRemove* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* unsafe_arena_release_reqstrategyremove();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyRemove& _internal_reqstrategyremove() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* _internal_mutable_reqstrategyremove();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyAbort reqStrategyAbort = 21;
  bool has_reqstrategyabort() const;
  private:
  bool _internal_has_reqstrategyabort() const;

  public:
  void clear_reqstrategyabort() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyAbort& reqstrategyabort() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* release_reqstrategyabort();
  ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* mutable_reqstrategyabort();
  void set_allocated_reqstrategyabort(::lampyris::crypto::protocol::strategy::ReqStrategyAbort* value);
  void unsafe_arena_set_allocated_reqstrategyabort(::lampyris::crypto::protocol::strategy::ReqStrategyAbort* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* unsafe_arena_release_reqstrategyabort();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyAbort& _internal_reqstrategyabort() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* _internal_mutable_reqstrategyabort();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus reqStrategyEnableStatus = 22;
  bool has_reqstrategyenablestatus() const;
  private:
  bool _internal_has_reqstrategyenablestatus() const;

  public:
  void clear_reqstrategyenablestatus() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus& reqstrategyenablestatus() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* release_reqstrategyenablestatus();
  ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* mutable_reqstrategyenablestatus();
  void set_allocated_reqstrategyenablestatus(::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* value);
  void unsafe_arena_set_allocated_reqstrategyenablestatus(::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* unsafe_arena_release_reqstrategyenablestatus();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus& _internal_reqstrategyenablestatus() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* _internal_mutable_reqstrategyenablestatus();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyQuery reqStrategyQuery = 23;
  bool has_reqstrategyquery() const;
  private:
  bool _internal_has_reqstrategyquery() const;

  public:
  void clear_reqstrategyquery() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyQuery& reqstrategyquery() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* release_reqstrategyquery();
  ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* mutable_reqstrategyquery();
  void set_allocated_reqstrategyquery(::lampyris::crypto::protocol::strategy::ReqStrategyQuery* value);
  void unsafe_arena_set_allocated_reqstrategyquery(::lampyris::crypto::protocol::strategy::ReqStrategyQuery* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* unsafe_arena_release_reqstrategyquery();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyQuery& _internal_reqstrategyquery() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* _internal_mutable_reqstrategyquery();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyUpgrade reqStrategyUpgrade = 24;
  bool has_reqstrategyupgrade() const;
  private:
  bool _internal_has_reqstrategyupgrade() const;

  public:
  void clear_reqstrategyupgrade() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade& reqstrategyupgrade() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* release_reqstrategyupgrade();
  ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* mutable_reqstrategyupgrade();
  void set_allocated_reqstrategyupgrade(::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* value);
  void unsafe_arena_set_allocated_reqstrategyupgrade(::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* unsafe_arena_release_reqstrategyupgrade();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade& _internal_reqstrategyupgrade() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* _internal_mutable_reqstrategyupgrade();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory reqStrategyExecutionHistory = 25;
  bool has_reqstrategyexecutionhistory() const;
  private:
  bool _internal_has_reqstrategyexecutionhistory() const;

  public:
  void clear_reqstrategyexecutionhistory() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory& reqstrategyexecutionhistory() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* release_reqstrategyexecutionhistory();
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* mutable_reqstrategyexecutionhistory();
  void set_allocated_reqstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* value);
  void unsafe_arena_set_allocated_reqstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* unsafe_arena_release_reqstrategyexecutionhistory();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory& _internal_reqstrategyexecutionhistory() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* _internal_mutable_reqstrategyexecutionhistory();

  public:
  // .lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog reqStrategyExecutionLog = 26;
  bool has_reqstrategyexecutionlog() const;
  private:
  bool _internal_has_reqstrategyexecutionlog() const;

  public:
  void clear_reqstrategyexecutionlog() ;
  const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog& reqstrategyexecutionlog() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* release_reqstrategyexecutionlog();
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* mutable_reqstrategyexecutionlog();
  void set_allocated_reqstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* value);
  void unsafe_arena_set_allocated_reqstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* value);
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* unsafe_arena_release_reqstrategyexecutionlog();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog& _internal_reqstrategyexecutionlog() const;
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* _internal_mutable_reqstrategyexecutionlog();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Request)
 private:
  class _Internal;
  void set_has_reqsubscribetickerdata();
  void set_has_reqsubscribetradedata();
  void set_has_reqsubscribecandlestickupdate();
  void set_has_reqcandlestickquery();
  void set_has_reqtraderule();
  void set_has_reqselfselectedsymbol();
  void set_has_reqplaceorder();
  void set_has_reqmodifyorder();
  void set_has_reqcancelorder();
  void set_has_reqonekeycloseposition();
  void set_has_reqqueryactiveorders();
  void set_has_reqqueryhistoricalorders();
  void set_has_reqquerypositions();
  void set_has_reqsetleverage();
  void set_has_reqqueryleverage();
  void set_has_reqqueryleveragebracket();
  void set_has_reqheartbeat();
  void set_has_reqserverlogquery();
  void set_has_reqstrategyadd();
  void set_has_reqstrategyremove();
  void set_has_reqstrategyabort();
  void set_has_reqstrategyenablestatus();
  void set_has_reqstrategyquery();
  void set_has_reqstrategyupgrade();
  void set_has_reqstrategyexecutionhistory();
  void set_has_reqstrategyexecutionlog();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 26, 26,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Request& from_msg);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* reqsubscribetickerdata_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* reqsubscribetradedata_;
      ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* reqsubscribecandlestickupdate_;
      ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* reqcandlestickquery_;
      ::lampyris::crypto::protocol::quote::ReqTradeRule* reqtraderule_;
      ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* reqselfselectedsymbol_;
      ::lampyris::crypto::protocol::trading::ReqPlaceOrder* reqplaceorder_;
      ::lampyris::crypto::protocol::trading::ReqModifyOrder* reqmodifyorder_;
      ::lampyris::crypto::protocol::trading::ReqCancelOrder* reqcancelorder_;
      ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* reqonekeycloseposition_;
      ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* reqqueryactiveorders_;
      ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* reqqueryhistoricalorders_;
      ::lampyris::crypto::protocol::trading::ReqQueryPositions* reqquerypositions_;
      ::lampyris::crypto::protocol::trading::ReqSetLeverage* reqsetleverage_;
      ::lampyris::crypto::protocol::trading::ReqQueryLeverage* reqqueryleverage_;
      ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* reqqueryleveragebracket_;
      ::lampyris::crypto::protocol::app::ReqHeartBeat* reqheartbeat_;
      ::lampyris::crypto::protocol::app::ReqServerLogQuery* reqserverlogquery_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* reqstrategyadd_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* reqstrategyremove_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* reqstrategyabort_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* reqstrategyenablestatus_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* reqstrategyquery_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* reqstrategyupgrade_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* reqstrategyexecutionhistory_;
      ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* reqstrategyexecutionlog_;
    } request_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 1;
inline bool Request::has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline bool Request::_internal_has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline void Request::set_has_reqsubscribetickerdata() {
  _impl_._oneof_case_[0] = kReqSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetickerdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::_internal_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData ? *_impl_.request_type_.reqsubscribetickerdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::reqsubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _internal_reqsubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::unsafe_arena_release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetickerdata_;
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::_internal_mutable_reqsubscribetickerdata() {
  if (request_type_case() != kReqSubscribeTickerData) {
    clear_request_type();
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData>(GetArena());
  }
  return _impl_.request_type_.reqsubscribetickerdata_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* Request::mutable_reqsubscribetickerdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* _msg = _internal_mutable_reqsubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 2;
inline bool Request::has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline bool Request::_internal_has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline void Request::set_has_reqsubscribetradedata() {
  _impl_._oneof_case_[0] = kReqSubscribeTradeData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetradedata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::_internal_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData ? *_impl_.request_type_.reqsubscribetradedata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTradeData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::reqsubscribetradedata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _internal_reqsubscribetradedata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::unsafe_arena_release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribetradedata_;
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::_internal_mutable_reqsubscribetradedata() {
  if (request_type_case() != kReqSubscribeTradeData) {
    clear_request_type();
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData>(GetArena());
  }
  return _impl_.request_type_.reqsubscribetradedata_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* Request::mutable_reqsubscribetradedata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* _msg = _internal_mutable_reqsubscribetradedata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 3;
inline bool Request::has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline bool Request::_internal_has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline void Request::set_has_reqsubscribecandlestickupdate() {
  _impl_._oneof_case_[0] = kReqSubscribeCandlestickUpdate;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribecandlestickupdate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::_internal_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate ? *_impl_.request_type_.reqsubscribecandlestickupdate_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate&>(::lampyris::crypto::protocol::quote::_ReqSubscribeCandlestickUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::reqsubscribecandlestickupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _internal_reqsubscribecandlestickupdate();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::unsafe_arena_release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsubscribecandlestickupdate_;
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::_internal_mutable_reqsubscribecandlestickupdate() {
  if (request_type_case() != kReqSubscribeCandlestickUpdate) {
    clear_request_type();
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate>(GetArena());
  }
  return _impl_.request_type_.reqsubscribecandlestickupdate_;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* Request::mutable_reqsubscribecandlestickupdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* _msg = _internal_mutable_reqsubscribecandlestickupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 4;
inline bool Request::has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline bool Request::_internal_has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline void Request::set_has_reqcandlestickquery() {
  _impl_._oneof_case_[0] = kReqCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcandlestickquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::_internal_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery ? *_impl_.request_type_.reqcandlestickquery_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ReqCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::reqcandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _internal_reqcandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::unsafe_arena_release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcandlestickquery_;
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::_internal_mutable_reqcandlestickquery() {
  if (request_type_case() != kReqCandlestickQuery) {
    clear_request_type();
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqCandlestickQuery>(GetArena());
  }
  return _impl_.request_type_.reqcandlestickquery_;
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* Request::mutable_reqcandlestickquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* _msg = _internal_mutable_reqcandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 5;
inline bool Request::has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline bool Request::_internal_has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline void Request::set_has_reqtraderule() {
  _impl_._oneof_case_[0] = kReqTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::release_reqtraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqtraderule_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::_internal_reqtraderule() const {
  return request_type_case() == kReqTradeRule ? *_impl_.request_type_.reqtraderule_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule&>(::lampyris::crypto::protocol::quote::_ReqTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::reqtraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _internal_reqtraderule();
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::unsafe_arena_release_reqtraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqtraderule_;
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::_internal_mutable_reqtraderule() {
  if (request_type_case() != kReqTradeRule) {
    clear_request_type();
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqTradeRule>(GetArena());
  }
  return _impl_.request_type_.reqtraderule_;
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* Request::mutable_reqtraderule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqTradeRule* _msg = _internal_mutable_reqtraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 6;
inline bool Request::has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline bool Request::_internal_has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline void Request::set_has_reqselfselectedsymbol() {
  _impl_._oneof_case_[0] = kReqSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqselfselectedsymbol_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::_internal_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol ? *_impl_.request_type_.reqselfselectedsymbol_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ReqSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::reqselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _internal_reqselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::unsafe_arena_release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqselfselectedsymbol_;
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::_internal_mutable_reqselfselectedsymbol() {
  if (request_type_case() != kReqSelfSelectedSymbol) {
    clear_request_type();
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol>(GetArena());
  }
  return _impl_.request_type_.reqselfselectedsymbol_;
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* Request::mutable_reqselfselectedsymbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* _msg = _internal_mutable_reqselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 7;
inline bool Request::has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline bool Request::_internal_has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline void Request::set_has_reqplaceorder() {
  _impl_._oneof_case_[0] = kReqPlaceOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::release_reqplaceorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqplaceorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::_internal_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder ? *_impl_.request_type_.reqplaceorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder&>(::lampyris::crypto::protocol::trading::_ReqPlaceOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::reqplaceorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _internal_reqplaceorder();
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::unsafe_arena_release_reqplaceorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqplaceorder_;
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::_internal_mutable_reqplaceorder() {
  if (request_type_case() != kReqPlaceOrder) {
    clear_request_type();
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqPlaceOrder>(GetArena());
  }
  return _impl_.request_type_.reqplaceorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* Request::mutable_reqplaceorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* _msg = _internal_mutable_reqplaceorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 8;
inline bool Request::has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline bool Request::_internal_has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline void Request::set_has_reqmodifyorder() {
  _impl_._oneof_case_[0] = kReqModifyOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::release_reqmodifyorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifyorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::_internal_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder ? *_impl_.request_type_.reqmodifyorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder&>(::lampyris::crypto::protocol::trading::_ReqModifyOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::reqmodifyorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _internal_reqmodifyorder();
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::unsafe_arena_release_reqmodifyorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqmodifyorder_;
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqModifyOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::_internal_mutable_reqmodifyorder() {
  if (request_type_case() != kReqModifyOrder) {
    clear_request_type();
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqModifyOrder>(GetArena());
  }
  return _impl_.request_type_.reqmodifyorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* Request::mutable_reqmodifyorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* _msg = _internal_mutable_reqmodifyorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 9;
inline bool Request::has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline bool Request::_internal_has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline void Request::set_has_reqcancelorder() {
  _impl_._oneof_case_[0] = kReqCancelOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::release_reqcancelorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcancelorder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::_internal_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder ? *_impl_.request_type_.reqcancelorder_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder&>(::lampyris::crypto::protocol::trading::_ReqCancelOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::reqcancelorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _internal_reqcancelorder();
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::unsafe_arena_release_reqcancelorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqcancelorder_;
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCancelOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::_internal_mutable_reqcancelorder() {
  if (request_type_case() != kReqCancelOrder) {
    clear_request_type();
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqCancelOrder>(GetArena());
  }
  return _impl_.request_type_.reqcancelorder_;
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* Request::mutable_reqcancelorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* _msg = _internal_mutable_reqcancelorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 10;
inline bool Request::has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline bool Request::_internal_has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline void Request::set_has_reqonekeycloseposition() {
  _impl_._oneof_case_[0] = kReqOneKeyClosePosition;
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqonekeycloseposition_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::_internal_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition ? *_impl_.request_type_.reqonekeycloseposition_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition&>(::lampyris::crypto::protocol::trading::_ReqOneKeyClosePosition_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::reqonekeycloseposition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _internal_reqonekeycloseposition();
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::unsafe_arena_release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqonekeycloseposition_;
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::_internal_mutable_reqonekeycloseposition() {
  if (request_type_case() != kReqOneKeyClosePosition) {
    clear_request_type();
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition>(GetArena());
  }
  return _impl_.request_type_.reqonekeycloseposition_;
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* Request::mutable_reqonekeycloseposition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* _msg = _internal_mutable_reqonekeycloseposition();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 11;
inline bool Request::has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline bool Request::_internal_has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline void Request::set_has_reqqueryactiveorders() {
  _impl_._oneof_case_[0] = kReqQueryActiveOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryactiveorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::_internal_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders ? *_impl_.request_type_.reqqueryactiveorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryActiveOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::reqqueryactiveorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _internal_reqqueryactiveorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::unsafe_arena_release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryactiveorders_;
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::_internal_mutable_reqqueryactiveorders() {
  if (request_type_case() != kReqQueryActiveOrders) {
    clear_request_type();
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders>(GetArena());
  }
  return _impl_.request_type_.reqqueryactiveorders_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* Request::mutable_reqqueryactiveorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* _msg = _internal_mutable_reqqueryactiveorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 12;
inline bool Request::has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline bool Request::_internal_has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline void Request::set_has_reqqueryhistoricalorders() {
  _impl_._oneof_case_[0] = kReqQueryHistoricalOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryhistoricalorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::_internal_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders ? *_impl_.request_type_.reqqueryhistoricalorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryHistoricalOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::reqqueryhistoricalorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _internal_reqqueryhistoricalorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::unsafe_arena_release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryhistoricalorders_;
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::_internal_mutable_reqqueryhistoricalorders() {
  if (request_type_case() != kReqQueryHistoricalOrders) {
    clear_request_type();
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders>(GetArena());
  }
  return _impl_.request_type_.reqqueryhistoricalorders_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* Request::mutable_reqqueryhistoricalorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* _msg = _internal_mutable_reqqueryhistoricalorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 13;
inline bool Request::has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline bool Request::_internal_has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline void Request::set_has_reqquerypositions() {
  _impl_._oneof_case_[0] = kReqQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::release_reqquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerypositions_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::_internal_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions ? *_impl_.request_type_.reqquerypositions_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions&>(::lampyris::crypto::protocol::trading::_ReqQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::reqquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _internal_reqquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::unsafe_arena_release_reqquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqquerypositions_;
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::_internal_mutable_reqquerypositions() {
  if (request_type_case() != kReqQueryPositions) {
    clear_request_type();
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryPositions>(GetArena());
  }
  return _impl_.request_type_.reqquerypositions_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* Request::mutable_reqquerypositions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* _msg = _internal_mutable_reqquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 14;
inline bool Request::has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline bool Request::_internal_has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline void Request::set_has_reqsetleverage() {
  _impl_._oneof_case_[0] = kReqSetLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::release_reqsetleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsetleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::_internal_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage ? *_impl_.request_type_.reqsetleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage&>(::lampyris::crypto::protocol::trading::_ReqSetLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::reqsetleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _internal_reqsetleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::unsafe_arena_release_reqsetleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqsetleverage_;
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSetLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::_internal_mutable_reqsetleverage() {
  if (request_type_case() != kReqSetLeverage) {
    clear_request_type();
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqSetLeverage>(GetArena());
  }
  return _impl_.request_type_.reqsetleverage_;
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* Request::mutable_reqsetleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* _msg = _internal_mutable_reqsetleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 15;
inline bool Request::has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline bool Request::_internal_has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline void Request::set_has_reqqueryleverage() {
  _impl_._oneof_case_[0] = kReqQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::release_reqqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::_internal_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage ? *_impl_.request_type_.reqqueryleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::reqqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _internal_reqqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::unsafe_arena_release_reqqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleverage_;
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::_internal_mutable_reqqueryleverage() {
  if (request_type_case() != kReqQueryLeverage) {
    clear_request_type();
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverage>(GetArena());
  }
  return _impl_.request_type_.reqqueryleverage_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* Request::mutable_reqqueryleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* _msg = _internal_mutable_reqqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 16;
inline bool Request::has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline bool Request::_internal_has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline void Request::set_has_reqqueryleveragebracket() {
  _impl_._oneof_case_[0] = kReqQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleveragebracket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::_internal_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket ? *_impl_.request_type_.reqqueryleveragebracket_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::reqqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _internal_reqqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::unsafe_arena_release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqqueryleveragebracket_;
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::_internal_mutable_reqqueryleveragebracket() {
  if (request_type_case() != kReqQueryLeverageBracket) {
    clear_request_type();
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket>(GetArena());
  }
  return _impl_.request_type_.reqqueryleveragebracket_;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* Request::mutable_reqqueryleveragebracket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* _msg = _internal_mutable_reqqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 17;
inline bool Request::has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline bool Request::_internal_has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline void Request::set_has_reqheartbeat() {
  _impl_._oneof_case_[0] = kReqHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::release_reqheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqheartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::_internal_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat ? *_impl_.request_type_.reqheartbeat_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat&>(::lampyris::crypto::protocol::app::_ReqHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::reqheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _internal_reqheartbeat();
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::unsafe_arena_release_reqheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqheartbeat_;
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::_internal_mutable_reqheartbeat() {
  if (request_type_case() != kReqHeartBeat) {
    clear_request_type();
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqHeartBeat>(GetArena());
  }
  return _impl_.request_type_.reqheartbeat_;
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* Request::mutable_reqheartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqHeartBeat* _msg = _internal_mutable_reqheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqServerLogQuery reqServerLogQuery = 18;
inline bool Request::has_reqserverlogquery() const {
  return request_type_case() == kReqServerLogQuery;
}
inline bool Request::_internal_has_reqserverlogquery() const {
  return request_type_case() == kReqServerLogQuery;
}
inline void Request::set_has_reqserverlogquery() {
  _impl_._oneof_case_[0] = kReqServerLogQuery;
}
inline ::lampyris::crypto::protocol::app::ReqServerLogQuery* Request::release_reqserverlogquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqServerLogQuery)
  if (request_type_case() == kReqServerLogQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqserverlogquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqserverlogquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqServerLogQuery& Request::_internal_reqserverlogquery() const {
  return request_type_case() == kReqServerLogQuery ? *_impl_.request_type_.reqserverlogquery_ : reinterpret_cast<::lampyris::crypto::protocol::app::ReqServerLogQuery&>(::lampyris::crypto::protocol::app::_ReqServerLogQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqServerLogQuery& Request::reqserverlogquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqServerLogQuery)
  return _internal_reqserverlogquery();
}
inline ::lampyris::crypto::protocol::app::ReqServerLogQuery* Request::unsafe_arena_release_reqserverlogquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqServerLogQuery)
  if (request_type_case() == kReqServerLogQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqserverlogquery_;
    _impl_.request_type_.reqserverlogquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqserverlogquery(::lampyris::crypto::protocol::app::ReqServerLogQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqserverlogquery();
    _impl_.request_type_.reqserverlogquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqServerLogQuery)
}
inline ::lampyris::crypto::protocol::app::ReqServerLogQuery* Request::_internal_mutable_reqserverlogquery() {
  if (request_type_case() != kReqServerLogQuery) {
    clear_request_type();
    set_has_reqserverlogquery();
    _impl_.request_type_.reqserverlogquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqServerLogQuery>(GetArena());
  }
  return _impl_.request_type_.reqserverlogquery_;
}
inline ::lampyris::crypto::protocol::app::ReqServerLogQuery* Request::mutable_reqserverlogquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqServerLogQuery* _msg = _internal_mutable_reqserverlogquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqServerLogQuery)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyAdd reqStrategyAdd = 19;
inline bool Request::has_reqstrategyadd() const {
  return request_type_case() == kReqStrategyAdd;
}
inline bool Request::_internal_has_reqstrategyadd() const {
  return request_type_case() == kReqStrategyAdd;
}
inline void Request::set_has_reqstrategyadd() {
  _impl_._oneof_case_[0] = kReqStrategyAdd;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* Request::release_reqstrategyadd() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyAdd)
  if (request_type_case() == kReqStrategyAdd) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyadd_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyadd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyAdd& Request::_internal_reqstrategyadd() const {
  return request_type_case() == kReqStrategyAdd ? *_impl_.request_type_.reqstrategyadd_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyAdd&>(::lampyris::crypto::protocol::strategy::_ReqStrategyAdd_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyAdd& Request::reqstrategyadd() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyAdd)
  return _internal_reqstrategyadd();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* Request::unsafe_arena_release_reqstrategyadd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyAdd)
  if (request_type_case() == kReqStrategyAdd) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyadd_;
    _impl_.request_type_.reqstrategyadd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyadd(::lampyris::crypto::protocol::strategy::ReqStrategyAdd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyadd();
    _impl_.request_type_.reqstrategyadd_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyAdd)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* Request::_internal_mutable_reqstrategyadd() {
  if (request_type_case() != kReqStrategyAdd) {
    clear_request_type();
    set_has_reqstrategyadd();
    _impl_.request_type_.reqstrategyadd_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyAdd>(GetArena());
  }
  return _impl_.request_type_.reqstrategyadd_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* Request::mutable_reqstrategyadd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyAdd* _msg = _internal_mutable_reqstrategyadd();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyAdd)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyRemove reqStrategyRemove = 20;
inline bool Request::has_reqstrategyremove() const {
  return request_type_case() == kReqStrategyRemove;
}
inline bool Request::_internal_has_reqstrategyremove() const {
  return request_type_case() == kReqStrategyRemove;
}
inline void Request::set_has_reqstrategyremove() {
  _impl_._oneof_case_[0] = kReqStrategyRemove;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* Request::release_reqstrategyremove() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyRemove)
  if (request_type_case() == kReqStrategyRemove) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyremove_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyremove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyRemove& Request::_internal_reqstrategyremove() const {
  return request_type_case() == kReqStrategyRemove ? *_impl_.request_type_.reqstrategyremove_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyRemove&>(::lampyris::crypto::protocol::strategy::_ReqStrategyRemove_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyRemove& Request::reqstrategyremove() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyRemove)
  return _internal_reqstrategyremove();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* Request::unsafe_arena_release_reqstrategyremove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyRemove)
  if (request_type_case() == kReqStrategyRemove) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyremove_;
    _impl_.request_type_.reqstrategyremove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyremove(::lampyris::crypto::protocol::strategy::ReqStrategyRemove* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyremove();
    _impl_.request_type_.reqstrategyremove_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyRemove)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* Request::_internal_mutable_reqstrategyremove() {
  if (request_type_case() != kReqStrategyRemove) {
    clear_request_type();
    set_has_reqstrategyremove();
    _impl_.request_type_.reqstrategyremove_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyRemove>(GetArena());
  }
  return _impl_.request_type_.reqstrategyremove_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* Request::mutable_reqstrategyremove() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyRemove* _msg = _internal_mutable_reqstrategyremove();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyRemove)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyAbort reqStrategyAbort = 21;
inline bool Request::has_reqstrategyabort() const {
  return request_type_case() == kReqStrategyAbort;
}
inline bool Request::_internal_has_reqstrategyabort() const {
  return request_type_case() == kReqStrategyAbort;
}
inline void Request::set_has_reqstrategyabort() {
  _impl_._oneof_case_[0] = kReqStrategyAbort;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* Request::release_reqstrategyabort() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyAbort)
  if (request_type_case() == kReqStrategyAbort) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyabort_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyabort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyAbort& Request::_internal_reqstrategyabort() const {
  return request_type_case() == kReqStrategyAbort ? *_impl_.request_type_.reqstrategyabort_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyAbort&>(::lampyris::crypto::protocol::strategy::_ReqStrategyAbort_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyAbort& Request::reqstrategyabort() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyAbort)
  return _internal_reqstrategyabort();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* Request::unsafe_arena_release_reqstrategyabort() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyAbort)
  if (request_type_case() == kReqStrategyAbort) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyabort_;
    _impl_.request_type_.reqstrategyabort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyabort(::lampyris::crypto::protocol::strategy::ReqStrategyAbort* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyabort();
    _impl_.request_type_.reqstrategyabort_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyAbort)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* Request::_internal_mutable_reqstrategyabort() {
  if (request_type_case() != kReqStrategyAbort) {
    clear_request_type();
    set_has_reqstrategyabort();
    _impl_.request_type_.reqstrategyabort_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyAbort>(GetArena());
  }
  return _impl_.request_type_.reqstrategyabort_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* Request::mutable_reqstrategyabort() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyAbort* _msg = _internal_mutable_reqstrategyabort();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyAbort)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyEnableStatus reqStrategyEnableStatus = 22;
inline bool Request::has_reqstrategyenablestatus() const {
  return request_type_case() == kReqStrategyEnableStatus;
}
inline bool Request::_internal_has_reqstrategyenablestatus() const {
  return request_type_case() == kReqStrategyEnableStatus;
}
inline void Request::set_has_reqstrategyenablestatus() {
  _impl_._oneof_case_[0] = kReqStrategyEnableStatus;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* Request::release_reqstrategyenablestatus() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyEnableStatus)
  if (request_type_case() == kReqStrategyEnableStatus) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyenablestatus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyenablestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus& Request::_internal_reqstrategyenablestatus() const {
  return request_type_case() == kReqStrategyEnableStatus ? *_impl_.request_type_.reqstrategyenablestatus_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus&>(::lampyris::crypto::protocol::strategy::_ReqStrategyEnableStatus_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus& Request::reqstrategyenablestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyEnableStatus)
  return _internal_reqstrategyenablestatus();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* Request::unsafe_arena_release_reqstrategyenablestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyEnableStatus)
  if (request_type_case() == kReqStrategyEnableStatus) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyenablestatus_;
    _impl_.request_type_.reqstrategyenablestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyenablestatus(::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyenablestatus();
    _impl_.request_type_.reqstrategyenablestatus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyEnableStatus)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* Request::_internal_mutable_reqstrategyenablestatus() {
  if (request_type_case() != kReqStrategyEnableStatus) {
    clear_request_type();
    set_has_reqstrategyenablestatus();
    _impl_.request_type_.reqstrategyenablestatus_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus>(GetArena());
  }
  return _impl_.request_type_.reqstrategyenablestatus_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* Request::mutable_reqstrategyenablestatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyEnableStatus* _msg = _internal_mutable_reqstrategyenablestatus();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyEnableStatus)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyQuery reqStrategyQuery = 23;
inline bool Request::has_reqstrategyquery() const {
  return request_type_case() == kReqStrategyQuery;
}
inline bool Request::_internal_has_reqstrategyquery() const {
  return request_type_case() == kReqStrategyQuery;
}
inline void Request::set_has_reqstrategyquery() {
  _impl_._oneof_case_[0] = kReqStrategyQuery;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* Request::release_reqstrategyquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyQuery)
  if (request_type_case() == kReqStrategyQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyQuery& Request::_internal_reqstrategyquery() const {
  return request_type_case() == kReqStrategyQuery ? *_impl_.request_type_.reqstrategyquery_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyQuery&>(::lampyris::crypto::protocol::strategy::_ReqStrategyQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyQuery& Request::reqstrategyquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyQuery)
  return _internal_reqstrategyquery();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* Request::unsafe_arena_release_reqstrategyquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyQuery)
  if (request_type_case() == kReqStrategyQuery) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyquery_;
    _impl_.request_type_.reqstrategyquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyquery(::lampyris::crypto::protocol::strategy::ReqStrategyQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyquery();
    _impl_.request_type_.reqstrategyquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyQuery)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* Request::_internal_mutable_reqstrategyquery() {
  if (request_type_case() != kReqStrategyQuery) {
    clear_request_type();
    set_has_reqstrategyquery();
    _impl_.request_type_.reqstrategyquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyQuery>(GetArena());
  }
  return _impl_.request_type_.reqstrategyquery_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* Request::mutable_reqstrategyquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyQuery* _msg = _internal_mutable_reqstrategyquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyQuery)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyUpgrade reqStrategyUpgrade = 24;
inline bool Request::has_reqstrategyupgrade() const {
  return request_type_case() == kReqStrategyUpgrade;
}
inline bool Request::_internal_has_reqstrategyupgrade() const {
  return request_type_case() == kReqStrategyUpgrade;
}
inline void Request::set_has_reqstrategyupgrade() {
  _impl_._oneof_case_[0] = kReqStrategyUpgrade;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* Request::release_reqstrategyupgrade() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyUpgrade)
  if (request_type_case() == kReqStrategyUpgrade) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyupgrade_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyupgrade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade& Request::_internal_reqstrategyupgrade() const {
  return request_type_case() == kReqStrategyUpgrade ? *_impl_.request_type_.reqstrategyupgrade_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade&>(::lampyris::crypto::protocol::strategy::_ReqStrategyUpgrade_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade& Request::reqstrategyupgrade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyUpgrade)
  return _internal_reqstrategyupgrade();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* Request::unsafe_arena_release_reqstrategyupgrade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyUpgrade)
  if (request_type_case() == kReqStrategyUpgrade) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyupgrade_;
    _impl_.request_type_.reqstrategyupgrade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyupgrade(::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyupgrade();
    _impl_.request_type_.reqstrategyupgrade_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyUpgrade)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* Request::_internal_mutable_reqstrategyupgrade() {
  if (request_type_case() != kReqStrategyUpgrade) {
    clear_request_type();
    set_has_reqstrategyupgrade();
    _impl_.request_type_.reqstrategyupgrade_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade>(GetArena());
  }
  return _impl_.request_type_.reqstrategyupgrade_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* Request::mutable_reqstrategyupgrade() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyUpgrade* _msg = _internal_mutable_reqstrategyupgrade();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyUpgrade)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyExecutionHistory reqStrategyExecutionHistory = 25;
inline bool Request::has_reqstrategyexecutionhistory() const {
  return request_type_case() == kReqStrategyExecutionHistory;
}
inline bool Request::_internal_has_reqstrategyexecutionhistory() const {
  return request_type_case() == kReqStrategyExecutionHistory;
}
inline void Request::set_has_reqstrategyexecutionhistory() {
  _impl_._oneof_case_[0] = kReqStrategyExecutionHistory;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* Request::release_reqstrategyexecutionhistory() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyExecutionHistory)
  if (request_type_case() == kReqStrategyExecutionHistory) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyexecutionhistory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyexecutionhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory& Request::_internal_reqstrategyexecutionhistory() const {
  return request_type_case() == kReqStrategyExecutionHistory ? *_impl_.request_type_.reqstrategyexecutionhistory_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory&>(::lampyris::crypto::protocol::strategy::_ReqStrategyExecutionHistory_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory& Request::reqstrategyexecutionhistory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyExecutionHistory)
  return _internal_reqstrategyexecutionhistory();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* Request::unsafe_arena_release_reqstrategyexecutionhistory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyExecutionHistory)
  if (request_type_case() == kReqStrategyExecutionHistory) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyexecutionhistory_;
    _impl_.request_type_.reqstrategyexecutionhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyexecutionhistory();
    _impl_.request_type_.reqstrategyexecutionhistory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyExecutionHistory)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* Request::_internal_mutable_reqstrategyexecutionhistory() {
  if (request_type_case() != kReqStrategyExecutionHistory) {
    clear_request_type();
    set_has_reqstrategyexecutionhistory();
    _impl_.request_type_.reqstrategyexecutionhistory_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory>(GetArena());
  }
  return _impl_.request_type_.reqstrategyexecutionhistory_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* Request::mutable_reqstrategyexecutionhistory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionHistory* _msg = _internal_mutable_reqstrategyexecutionhistory();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyExecutionHistory)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqStrategyExecutionLog reqStrategyExecutionLog = 26;
inline bool Request::has_reqstrategyexecutionlog() const {
  return request_type_case() == kReqStrategyExecutionLog;
}
inline bool Request::_internal_has_reqstrategyexecutionlog() const {
  return request_type_case() == kReqStrategyExecutionLog;
}
inline void Request::set_has_reqstrategyexecutionlog() {
  _impl_._oneof_case_[0] = kReqStrategyExecutionLog;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* Request::release_reqstrategyexecutionlog() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqStrategyExecutionLog)
  if (request_type_case() == kReqStrategyExecutionLog) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyexecutionlog_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqstrategyexecutionlog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog& Request::_internal_reqstrategyexecutionlog() const {
  return request_type_case() == kReqStrategyExecutionLog ? *_impl_.request_type_.reqstrategyexecutionlog_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog&>(::lampyris::crypto::protocol::strategy::_ReqStrategyExecutionLog_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog& Request::reqstrategyexecutionlog() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqStrategyExecutionLog)
  return _internal_reqstrategyexecutionlog();
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* Request::unsafe_arena_release_reqstrategyexecutionlog() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqStrategyExecutionLog)
  if (request_type_case() == kReqStrategyExecutionLog) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.reqstrategyexecutionlog_;
    _impl_.request_type_.reqstrategyexecutionlog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqstrategyexecutionlog();
    _impl_.request_type_.reqstrategyexecutionlog_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqStrategyExecutionLog)
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* Request::_internal_mutable_reqstrategyexecutionlog() {
  if (request_type_case() != kReqStrategyExecutionLog) {
    clear_request_type();
    set_has_reqstrategyexecutionlog();
    _impl_.request_type_.reqstrategyexecutionlog_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog>(GetArena());
  }
  return _impl_.request_type_.reqstrategyexecutionlog_;
}
inline ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* Request::mutable_reqstrategyexecutionlog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqStrategyExecutionLog* _msg = _internal_mutable_reqstrategyexecutionlog();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqStrategyExecutionLog)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 1;
inline bool Response::has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline bool Response::_internal_has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline void Response::set_has_ressubscribetickerdata() {
  _impl_._oneof_case_[0] = kResSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.ressubscribetickerdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::_internal_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData ? *_impl_.response_type_.ressubscribetickerdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ResSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::ressubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _internal_ressubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::unsafe_arena_release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.ressubscribetickerdata_;
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::_internal_mutable_ressubscribetickerdata() {
  if (response_type_case() != kResSubscribeTickerData) {
    clear_response_type();
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSubscribeTickerData>(GetArena());
  }
  return _impl_.response_type_.ressubscribetickerdata_;
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* Response::mutable_ressubscribetickerdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* _msg = _internal_mutable_ressubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 2;
inline bool Response::has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline bool Response::_internal_has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline void Response::set_has_rescandlestickquery() {
  _impl_._oneof_case_[0] = kResCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::release_rescandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.rescandlestickquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::_internal_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery ? *_impl_.response_type_.rescandlestickquery_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ResCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::rescandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _internal_rescandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::unsafe_arena_release_rescandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.rescandlestickquery_;
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::_internal_mutable_rescandlestickquery() {
  if (response_type_case() != kResCandlestickQuery) {
    clear_response_type();
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResCandlestickQuery>(GetArena());
  }
  return _impl_.response_type_.rescandlestickquery_;
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* Response::mutable_rescandlestickquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* _msg = _internal_mutable_rescandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 3;
inline bool Response::has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline bool Response::_internal_has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline void Response::set_has_restraderule() {
  _impl_._oneof_case_[0] = kResTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::release_restraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.restraderule_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::_internal_restraderule() const {
  return response_type_case() == kResTradeRule ? *_impl_.response_type_.restraderule_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule&>(::lampyris::crypto::protocol::quote::_ResTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::restraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _internal_restraderule();
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::unsafe_arena_release_restraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.restraderule_;
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_restraderule();
    _impl_.response_type_.restraderule_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::_internal_mutable_restraderule() {
  if (response_type_case() != kResTradeRule) {
    clear_response_type();
    set_has_restraderule();
    _impl_.response_type_.restraderule_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResTradeRule>(GetArena());
  }
  return _impl_.response_type_.restraderule_;
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* Response::mutable_restraderule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResTradeRule* _msg = _internal_mutable_restraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 4;
inline bool Response::has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline bool Response::_internal_has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline void Response::set_has_resselfselectedsymbol() {
  _impl_._oneof_case_[0] = kResSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resselfselectedsymbol_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::_internal_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol ? *_impl_.response_type_.resselfselectedsymbol_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ResSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::resselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _internal_resselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::unsafe_arena_release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resselfselectedsymbol_;
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::_internal_mutable_resselfselectedsymbol() {
  if (response_type_case() != kResSelfSelectedSymbol) {
    clear_response_type();
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol>(GetArena());
  }
  return _impl_.response_type_.resselfselectedsymbol_;
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* Response::mutable_resselfselectedsymbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* _msg = _internal_mutable_resselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 5;
inline bool Response::has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline bool Response::_internal_has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline void Response::set_has_resmarketpreviewdata() {
  _impl_._oneof_case_[0] = kResMarketPreviewData;
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmarketpreviewdata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::_internal_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData ? *_impl_.response_type_.resmarketpreviewdata_ : reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData&>(::lampyris::crypto::protocol::quote::_ResMarketPreviewData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::resmarketpreviewdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _internal_resmarketpreviewdata();
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::unsafe_arena_release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resmarketpreviewdata_;
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::_internal_mutable_resmarketpreviewdata() {
  if (response_type_case() != kResMarketPreviewData) {
    clear_response_type();
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResMarketPreviewData>(GetArena());
  }
  return _impl_.response_type_.resmarketpreviewdata_;
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* Response::mutable_resmarketpreviewdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* _msg = _internal_mutable_resmarketpreviewdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 6;
inline bool Response::has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline bool Response::_internal_has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline void Response::set_has_resqueryorders() {
  _impl_._oneof_case_[0] = kResQueryOrders;
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::release_resqueryorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryorders_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::_internal_resqueryorders() const {
  return response_type_case() == kResQueryOrders ? *_impl_.response_type_.resqueryorders_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders&>(::lampyris::crypto::protocol::trading::_ResQueryOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::resqueryorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _internal_resqueryorders();
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::unsafe_arena_release_resqueryorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryorders_;
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryOrders)
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::_internal_mutable_resqueryorders() {
  if (response_type_case() != kResQueryOrders) {
    clear_response_type();
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryOrders>(GetArena());
  }
  return _impl_.response_type_.resqueryorders_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* Response::mutable_resqueryorders() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryOrders* _msg = _internal_mutable_resqueryorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 7;
inline bool Response::has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline bool Response::_internal_has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline void Response::set_has_resquerypositions() {
  _impl_._oneof_case_[0] = kResQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::release_resquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerypositions_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::_internal_resquerypositions() const {
  return response_type_case() == kResQueryPositions ? *_impl_.response_type_.resquerypositions_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions&>(::lampyris::crypto::protocol::trading::_ResQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::resquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _internal_resquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::unsafe_arena_release_resquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resquerypositions_;
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::_internal_mutable_resquerypositions() {
  if (response_type_case() != kResQueryPositions) {
    clear_response_type();
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryPositions>(GetArena());
  }
  return _impl_.response_type_.resquerypositions_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* Response::mutable_resquerypositions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryPositions* _msg = _internal_mutable_resquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 8;
inline bool Response::has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline bool Response::_internal_has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline void Response::set_has_resqueryleverage() {
  _impl_._oneof_case_[0] = kResQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::release_resqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleverage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::_internal_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage ? *_impl_.response_type_.resqueryleverage_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage&>(::lampyris::crypto::protocol::trading::_ResQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::resqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _internal_resqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::unsafe_arena_release_resqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleverage_;
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::_internal_mutable_resqueryleverage() {
  if (response_type_case() != kResQueryLeverage) {
    clear_response_type();
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverage>(GetArena());
  }
  return _impl_.response_type_.resqueryleverage_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* Response::mutable_resqueryleverage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* _msg = _internal_mutable_resqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 9;
inline bool Response::has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline bool Response::_internal_has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline void Response::set_has_resqueryleveragebracket() {
  _impl_._oneof_case_[0] = kResQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleveragebracket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::_internal_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket ? *_impl_.response_type_.resqueryleveragebracket_ : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ResQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::resqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _internal_resqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::unsafe_arena_release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resqueryleveragebracket_;
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::_internal_mutable_resqueryleveragebracket() {
  if (response_type_case() != kResQueryLeverageBracket) {
    clear_response_type();
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket>(GetArena());
  }
  return _impl_.response_type_.resqueryleveragebracket_;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* Response::mutable_resqueryleveragebracket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* _msg = _internal_mutable_resqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 10;
inline bool Response::has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline bool Response::_internal_has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline void Response::set_has_resheartbeat() {
  _impl_._oneof_case_[0] = kResHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::release_resheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resheartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::_internal_resheartbeat() const {
  return response_type_case() == kResHeartBeat ? *_impl_.response_type_.resheartbeat_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat&>(::lampyris::crypto::protocol::app::_ResHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::resheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _internal_resheartbeat();
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::unsafe_arena_release_resheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resheartbeat_;
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::_internal_mutable_resheartbeat() {
  if (response_type_case() != kResHeartBeat) {
    clear_response_type();
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResHeartBeat>(GetArena());
  }
  return _impl_.response_type_.resheartbeat_;
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* Response::mutable_resheartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResHeartBeat* _msg = _internal_mutable_resheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResClientMessage resClientMessage = 11;
inline bool Response::has_resclientmessage() const {
  return response_type_case() == kResClientMessage;
}
inline bool Response::_internal_has_resclientmessage() const {
  return response_type_case() == kResClientMessage;
}
inline void Response::set_has_resclientmessage() {
  _impl_._oneof_case_[0] = kResClientMessage;
}
inline ::lampyris::crypto::protocol::app::ResClientMessage* Response::release_resclientmessage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resClientMessage)
  if (response_type_case() == kResClientMessage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resclientmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resclientmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResClientMessage& Response::_internal_resclientmessage() const {
  return response_type_case() == kResClientMessage ? *_impl_.response_type_.resclientmessage_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResClientMessage&>(::lampyris::crypto::protocol::app::_ResClientMessage_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResClientMessage& Response::resclientmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resClientMessage)
  return _internal_resclientmessage();
}
inline ::lampyris::crypto::protocol::app::ResClientMessage* Response::unsafe_arena_release_resclientmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resClientMessage)
  if (response_type_case() == kResClientMessage) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resclientmessage_;
    _impl_.response_type_.resclientmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resclientmessage(::lampyris::crypto::protocol::app::ResClientMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resclientmessage();
    _impl_.response_type_.resclientmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resClientMessage)
}
inline ::lampyris::crypto::protocol::app::ResClientMessage* Response::_internal_mutable_resclientmessage() {
  if (response_type_case() != kResClientMessage) {
    clear_response_type();
    set_has_resclientmessage();
    _impl_.response_type_.resclientmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResClientMessage>(GetArena());
  }
  return _impl_.response_type_.resclientmessage_;
}
inline ::lampyris::crypto::protocol::app::ResClientMessage* Response::mutable_resclientmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResClientMessage* _msg = _internal_mutable_resclientmessage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resClientMessage)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResServerLogQuery resServerLogQuery = 12;
inline bool Response::has_resserverlogquery() const {
  return response_type_case() == kResServerLogQuery;
}
inline bool Response::_internal_has_resserverlogquery() const {
  return response_type_case() == kResServerLogQuery;
}
inline void Response::set_has_resserverlogquery() {
  _impl_._oneof_case_[0] = kResServerLogQuery;
}
inline ::lampyris::crypto::protocol::app::ResServerLogQuery* Response::release_resserverlogquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resServerLogQuery)
  if (response_type_case() == kResServerLogQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resserverlogquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resserverlogquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResServerLogQuery& Response::_internal_resserverlogquery() const {
  return response_type_case() == kResServerLogQuery ? *_impl_.response_type_.resserverlogquery_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResServerLogQuery&>(::lampyris::crypto::protocol::app::_ResServerLogQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResServerLogQuery& Response::resserverlogquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resServerLogQuery)
  return _internal_resserverlogquery();
}
inline ::lampyris::crypto::protocol::app::ResServerLogQuery* Response::unsafe_arena_release_resserverlogquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resServerLogQuery)
  if (response_type_case() == kResServerLogQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resserverlogquery_;
    _impl_.response_type_.resserverlogquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resserverlogquery(::lampyris::crypto::protocol::app::ResServerLogQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resserverlogquery();
    _impl_.response_type_.resserverlogquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resServerLogQuery)
}
inline ::lampyris::crypto::protocol::app::ResServerLogQuery* Response::_internal_mutable_resserverlogquery() {
  if (response_type_case() != kResServerLogQuery) {
    clear_response_type();
    set_has_resserverlogquery();
    _impl_.response_type_.resserverlogquery_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResServerLogQuery>(GetArena());
  }
  return _impl_.response_type_.resserverlogquery_;
}
inline ::lampyris::crypto::protocol::app::ResServerLogQuery* Response::mutable_resserverlogquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResServerLogQuery* _msg = _internal_mutable_resserverlogquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resServerLogQuery)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResServerLogPush resServerLogPush = 13;
inline bool Response::has_resserverlogpush() const {
  return response_type_case() == kResServerLogPush;
}
inline bool Response::_internal_has_resserverlogpush() const {
  return response_type_case() == kResServerLogPush;
}
inline void Response::set_has_resserverlogpush() {
  _impl_._oneof_case_[0] = kResServerLogPush;
}
inline ::lampyris::crypto::protocol::app::ResServerLogPush* Response::release_resserverlogpush() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resServerLogPush)
  if (response_type_case() == kResServerLogPush) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resserverlogpush_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resserverlogpush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResServerLogPush& Response::_internal_resserverlogpush() const {
  return response_type_case() == kResServerLogPush ? *_impl_.response_type_.resserverlogpush_ : reinterpret_cast<::lampyris::crypto::protocol::app::ResServerLogPush&>(::lampyris::crypto::protocol::app::_ResServerLogPush_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResServerLogPush& Response::resserverlogpush() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resServerLogPush)
  return _internal_resserverlogpush();
}
inline ::lampyris::crypto::protocol::app::ResServerLogPush* Response::unsafe_arena_release_resserverlogpush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resServerLogPush)
  if (response_type_case() == kResServerLogPush) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resserverlogpush_;
    _impl_.response_type_.resserverlogpush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resserverlogpush(::lampyris::crypto::protocol::app::ResServerLogPush* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resserverlogpush();
    _impl_.response_type_.resserverlogpush_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resServerLogPush)
}
inline ::lampyris::crypto::protocol::app::ResServerLogPush* Response::_internal_mutable_resserverlogpush() {
  if (response_type_case() != kResServerLogPush) {
    clear_response_type();
    set_has_resserverlogpush();
    _impl_.response_type_.resserverlogpush_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResServerLogPush>(GetArena());
  }
  return _impl_.response_type_.resserverlogpush_;
}
inline ::lampyris::crypto::protocol::app::ResServerLogPush* Response::mutable_resserverlogpush() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResServerLogPush* _msg = _internal_mutable_resserverlogpush();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resServerLogPush)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStrategyEnableStatus resStrategyEnableStatus = 14;
inline bool Response::has_resstrategyenablestatus() const {
  return response_type_case() == kResStrategyEnableStatus;
}
inline bool Response::_internal_has_resstrategyenablestatus() const {
  return response_type_case() == kResStrategyEnableStatus;
}
inline void Response::set_has_resstrategyenablestatus() {
  _impl_._oneof_case_[0] = kResStrategyEnableStatus;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* Response::release_resstrategyenablestatus() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStrategyEnableStatus)
  if (response_type_case() == kResStrategyEnableStatus) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyenablestatus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstrategyenablestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus& Response::_internal_resstrategyenablestatus() const {
  return response_type_case() == kResStrategyEnableStatus ? *_impl_.response_type_.resstrategyenablestatus_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus&>(::lampyris::crypto::protocol::strategy::_ResStrategyEnableStatus_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus& Response::resstrategyenablestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStrategyEnableStatus)
  return _internal_resstrategyenablestatus();
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* Response::unsafe_arena_release_resstrategyenablestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStrategyEnableStatus)
  if (response_type_case() == kResStrategyEnableStatus) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyenablestatus_;
    _impl_.response_type_.resstrategyenablestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstrategyenablestatus(::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstrategyenablestatus();
    _impl_.response_type_.resstrategyenablestatus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStrategyEnableStatus)
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* Response::_internal_mutable_resstrategyenablestatus() {
  if (response_type_case() != kResStrategyEnableStatus) {
    clear_response_type();
    set_has_resstrategyenablestatus();
    _impl_.response_type_.resstrategyenablestatus_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus>(GetArena());
  }
  return _impl_.response_type_.resstrategyenablestatus_;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* Response::mutable_resstrategyenablestatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStrategyEnableStatus* _msg = _internal_mutable_resstrategyenablestatus();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStrategyEnableStatus)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStrategyList resStrategyList = 15;
inline bool Response::has_resstrategylist() const {
  return response_type_case() == kResStrategyList;
}
inline bool Response::_internal_has_resstrategylist() const {
  return response_type_case() == kResStrategyList;
}
inline void Response::set_has_resstrategylist() {
  _impl_._oneof_case_[0] = kResStrategyList;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyList* Response::release_resstrategylist() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStrategyList)
  if (response_type_case() == kResStrategyList) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategylist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstrategylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyList& Response::_internal_resstrategylist() const {
  return response_type_case() == kResStrategyList ? *_impl_.response_type_.resstrategylist_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStrategyList&>(::lampyris::crypto::protocol::strategy::_ResStrategyList_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyList& Response::resstrategylist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStrategyList)
  return _internal_resstrategylist();
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyList* Response::unsafe_arena_release_resstrategylist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStrategyList)
  if (response_type_case() == kResStrategyList) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategylist_;
    _impl_.response_type_.resstrategylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstrategylist(::lampyris::crypto::protocol::strategy::ResStrategyList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstrategylist();
    _impl_.response_type_.resstrategylist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStrategyList)
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyList* Response::_internal_mutable_resstrategylist() {
  if (response_type_case() != kResStrategyList) {
    clear_response_type();
    set_has_resstrategylist();
    _impl_.response_type_.resstrategylist_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStrategyList>(GetArena());
  }
  return _impl_.response_type_.resstrategylist_;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyList* Response::mutable_resstrategylist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStrategyList* _msg = _internal_mutable_resstrategylist();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStrategyList)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStrategyUpgrade resStrategyUpgrade = 16;
inline bool Response::has_resstrategyupgrade() const {
  return response_type_case() == kResStrategyUpgrade;
}
inline bool Response::_internal_has_resstrategyupgrade() const {
  return response_type_case() == kResStrategyUpgrade;
}
inline void Response::set_has_resstrategyupgrade() {
  _impl_._oneof_case_[0] = kResStrategyUpgrade;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* Response::release_resstrategyupgrade() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStrategyUpgrade)
  if (response_type_case() == kResStrategyUpgrade) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyupgrade_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstrategyupgrade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade& Response::_internal_resstrategyupgrade() const {
  return response_type_case() == kResStrategyUpgrade ? *_impl_.response_type_.resstrategyupgrade_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStrategyUpgrade&>(::lampyris::crypto::protocol::strategy::_ResStrategyUpgrade_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade& Response::resstrategyupgrade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStrategyUpgrade)
  return _internal_resstrategyupgrade();
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* Response::unsafe_arena_release_resstrategyupgrade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStrategyUpgrade)
  if (response_type_case() == kResStrategyUpgrade) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyupgrade_;
    _impl_.response_type_.resstrategyupgrade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstrategyupgrade(::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstrategyupgrade();
    _impl_.response_type_.resstrategyupgrade_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStrategyUpgrade)
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* Response::_internal_mutable_resstrategyupgrade() {
  if (response_type_case() != kResStrategyUpgrade) {
    clear_response_type();
    set_has_resstrategyupgrade();
    _impl_.response_type_.resstrategyupgrade_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStrategyUpgrade>(GetArena());
  }
  return _impl_.response_type_.resstrategyupgrade_;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* Response::mutable_resstrategyupgrade() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStrategyUpgrade* _msg = _internal_mutable_resstrategyupgrade();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStrategyUpgrade)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStrategyExecutionHistory resStrategyExecutionHistory = 17;
inline bool Response::has_resstrategyexecutionhistory() const {
  return response_type_case() == kResStrategyExecutionHistory;
}
inline bool Response::_internal_has_resstrategyexecutionhistory() const {
  return response_type_case() == kResStrategyExecutionHistory;
}
inline void Response::set_has_resstrategyexecutionhistory() {
  _impl_._oneof_case_[0] = kResStrategyExecutionHistory;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* Response::release_resstrategyexecutionhistory() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStrategyExecutionHistory)
  if (response_type_case() == kResStrategyExecutionHistory) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyexecutionhistory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstrategyexecutionhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory& Response::_internal_resstrategyexecutionhistory() const {
  return response_type_case() == kResStrategyExecutionHistory ? *_impl_.response_type_.resstrategyexecutionhistory_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory&>(::lampyris::crypto::protocol::strategy::_ResStrategyExecutionHistory_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory& Response::resstrategyexecutionhistory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStrategyExecutionHistory)
  return _internal_resstrategyexecutionhistory();
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* Response::unsafe_arena_release_resstrategyexecutionhistory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStrategyExecutionHistory)
  if (response_type_case() == kResStrategyExecutionHistory) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyexecutionhistory_;
    _impl_.response_type_.resstrategyexecutionhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstrategyexecutionhistory(::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstrategyexecutionhistory();
    _impl_.response_type_.resstrategyexecutionhistory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStrategyExecutionHistory)
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* Response::_internal_mutable_resstrategyexecutionhistory() {
  if (response_type_case() != kResStrategyExecutionHistory) {
    clear_response_type();
    set_has_resstrategyexecutionhistory();
    _impl_.response_type_.resstrategyexecutionhistory_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory>(GetArena());
  }
  return _impl_.response_type_.resstrategyexecutionhistory_;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* Response::mutable_resstrategyexecutionhistory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionHistory* _msg = _internal_mutable_resstrategyexecutionhistory();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStrategyExecutionHistory)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStrategyExecutionLog resStrategyExecutionLog = 18;
inline bool Response::has_resstrategyexecutionlog() const {
  return response_type_case() == kResStrategyExecutionLog;
}
inline bool Response::_internal_has_resstrategyexecutionlog() const {
  return response_type_case() == kResStrategyExecutionLog;
}
inline void Response::set_has_resstrategyexecutionlog() {
  _impl_._oneof_case_[0] = kResStrategyExecutionLog;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* Response::release_resstrategyexecutionlog() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStrategyExecutionLog)
  if (response_type_case() == kResStrategyExecutionLog) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyexecutionlog_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstrategyexecutionlog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog& Response::_internal_resstrategyexecutionlog() const {
  return response_type_case() == kResStrategyExecutionLog ? *_impl_.response_type_.resstrategyexecutionlog_ : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog&>(::lampyris::crypto::protocol::strategy::_ResStrategyExecutionLog_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog& Response::resstrategyexecutionlog() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStrategyExecutionLog)
  return _internal_resstrategyexecutionlog();
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* Response::unsafe_arena_release_resstrategyexecutionlog() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStrategyExecutionLog)
  if (response_type_case() == kResStrategyExecutionLog) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.resstrategyexecutionlog_;
    _impl_.response_type_.resstrategyexecutionlog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstrategyexecutionlog(::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstrategyexecutionlog();
    _impl_.response_type_.resstrategyexecutionlog_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStrategyExecutionLog)
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* Response::_internal_mutable_resstrategyexecutionlog() {
  if (response_type_case() != kResStrategyExecutionLog) {
    clear_response_type();
    set_has_resstrategyexecutionlog();
    _impl_.response_type_.resstrategyexecutionlog_ =
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog>(GetArena());
  }
  return _impl_.response_type_.resstrategyexecutionlog_;
}
inline ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* Response::mutable_resstrategyexecutionlog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStrategyExecutionLog* _msg = _internal_mutable_resstrategyexecutionlog();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStrategyExecutionLog)
  return _msg;
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // common_2eproto_2epb_2eh
